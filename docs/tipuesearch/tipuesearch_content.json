{"pages":[{"title":"Projet DUT AS - 2048","text":"\u00c2\u00a9 Copyright 2017","tags":"","url":"index.html"},{"title":"Installation","text":"Auteur : Steeve Jerent Pr\u00c3\u00a9requis : Lancement de l'application. Lancement des Tests Unitaires Auteur : Steeve Jerent Pr\u00c3\u00a9requis : make gcc Lancement de l'application. Pour compiler l'application : $ make compile Ex\u00c3\u00a9cuter l'application : $ .\/2048 # Ou faire la commande suivante pour supprimer l'ancienne ex\u00c3\u00a9cutable # cr\u00c3\u00a9er un nouvel ex\u00c3\u00a9cutable et l'ex\u00c3\u00a9cuter. $ make run Lancement des Tests Unitaires Compiler le programme de test : $ make compileTest Ex\u00c3\u00a9cuter le programme de test: $ .\/test # Ou faire la commande suivante pour supprimer l'ancien ex\u00c3\u00a9cutable # cr\u00c3\u00a9er un nouvel ex\u00c3\u00a9cutable et l'ex\u00c3\u00a9cuter. $ make test","tags":"","url":"Manuel_utilisateur\/Installation.html"},{"title":"Comment jouer","text":"Auteur : Tony Clonier 1 - R\u00c3\u00a8gles du jeu : Source : 2 - Lancement du jeu : 3 - Menu 3.1. - Cr\u00c3\u00a9er une nouvelle partie 3.2. - Jouer 3.3. - Sauvegarder 3.4. - Charger 3.5. - Afficher scores 3.6. - Quitter Auteur : Tony Clonier 1 - R\u00c3\u00a8gles du jeu : Le gameplay du jeu repose sur l'utilisation des touches fl\u00c3\u00a9ch\u00c3\u00a9es du clavier d\u00e2\u0080\u0099ordinateur pour d\u00c3\u00a9placer les tuiles vers la gauche, la droite, le haut ou le bas. Lors d'un mouvement, l'ensemble des tuiles du plateau sont d\u00c3\u00a9plac\u00c3\u00a9es dans la m\u00c3\u00aame direction jusqu'\u00c3\u00a0 rencontrer les bords du plateau ou une autre tuile sur leur chemin. Si deux tuiles, ayant le m\u00c3\u00aame nombre, entrent en collision durant le mouvement, elles fusionnent en une nouvelle tuile de valeur double (par ex. : deux tuiles de valeur \u00c2\u00ab 2 \u00c2\u00bb donnent une tuile de valeur \u00c2\u00ab 4 \u00c2\u00bb). \u00c3\u0080 chaque mouvement, une tuile portant un 2 ou un 4 appara\u00c3\u00aet dans une case vide de mani\u00c3\u00a8re al\u00c3\u00a9atoire. Le jeu, simple au d\u00c3\u00a9but, se complexifie de plus en plus, du fait du manque de place pour faire bouger les tuiles, et des erreurs de manipulation possibles, pouvant entra\u00c3\u00aener un blocage des tuiles et donc la fin du jeu \u00c3\u00a0 plus ou moins long terme, selon l\u00e2\u0080\u0099habilet\u00c3\u00a9 du joueur. La partie est gagn\u00c3\u00a9e lorsqu'une tuile portant la valeur \u00c2\u00ab 2048 \u00c2\u00bb appara\u00c3\u00aet sur la grille, d'o\u00c3\u00b9 le nom du jeu. Source : https:\/\/fr.wikipedia.org\/wiki\/2048_(jeu_vid\u00c3\u00a9o) 2 - Lancement du jeu : Lors du lancement du jeu, le menu s'ouvre et une nouvelle partie est automatiquement initialis\u00c3\u00a9e. La partie en cours est affich\u00c3\u00a9e en permanence dans le terminal pour aider l'utilisateur \u00c3\u00a0 se rep\u00c3\u00a9rer lors des diff\u00c3\u00a9rents enregistrements\/chargements de parties. 3 - Menu 3.1. - Cr\u00c3\u00a9er une nouvelle partie Dans le menu, appuyez sur la touche 1 pour cr\u00c3\u00a9er une nouvelle partie. Lors de la cr\u00c3\u00a9ation d'une nouvelle partie, l'utilisateur peut choisir la taille de la grille sur laquelle il souhaite jouer. La taille de la grille doit \u00c3\u00aatre comprise entre 3*3 et 8*8. 3.2. - Jouer Dans le menu, appuyez sur la touche 2 pour jouer \u00c3\u00a0 une partie (cr\u00c3\u00a9\u00c3\u00a9e ou charg\u00c3\u00a9e). Les tuiles doivent \u00c3\u00aatre d\u00c3\u00a9plac\u00c3\u00a9es \u00c3\u00a0 partir des fl\u00c3\u00a8ches multidirectionnelles du clavier. Il est possible d'appuyer sur la touche ECHAP pour retourner dans le menu. Une fois la partie perdue ou gagn\u00c3\u00a9e, il est possible d'enregistrer son score. 3.3. - Sauvegarder Dans le menu, appuyez sur la touche 3 pour sauvegarder la partie en cours. Il y a 3 slots de sauvegarde disponibles. Si un slot est d\u00c3\u00a9j\u00c3\u00a0 utilis\u00c3\u00a9, le jeu demande l'autorisation \u00c3\u00a0 l'utilisateur d'\u00c3\u00a9craser la sauvegarde pr\u00c3\u00a9c\u00c3\u00a9dente. 3.4. - Charger Dans le menu, appuyez sur la touche 4 pour charger une partie. Si le slot \u00c3\u00a0 charger est vide, l'utilisateur est averti. 3.5. - Afficher scores Dans le menu, appuyez sur la touche 5 pour afficher les scores des joueurs. 3.6. - Quitter Dans le menu, appuyez sur la touche 6 pour quitter le jeu.","tags":"","url":"Manuel_utilisateur\/Comment_jouer.html"},{"title":"Introduction","text":"Auteur : Tony Clonier Introduction 1 - Analyse fonctionnelle 1.1. La grille de jeu 1.2. Jouer au jeu 1.3. Sauvegarder et charger une partie 2 - R\u00c3\u00a9partition des t\u00c3\u00a2ches Auteur : Tony Clonier Introduction Dans cette partie, nous allons tenter d'expliquer la d\u00c3\u00a9composition fonctionnelle du programme. 1 - Analyse fonctionnelle Les r\u00c3\u00a8gles du jeu peuvent nous aider \u00c3\u00a0 identifier les principaux besoins fonctionnels : Cr\u00c3\u00a9er et initialiser la grille de jeu Jouer au jeu Sauvegarder une ou plusieurs parties Charger les parties sauvegard\u00c3\u00a9es 1.1. La grille de jeu Les r\u00c3\u00a8gles du jeu peuvent nous aider \u00c3\u00a0 d\u00c3\u00a9finir les variables n\u00c3\u00a9cessaires \u00c3\u00a0 la d\u00c3\u00a9finition de la grille. Pour faciliter l'utilisation des ces variables et le passage par r\u00c3\u00a9f\u00c3\u00a9rence, ces variables sont stock\u00c3\u00a9es dans une structure nomm\u00c3\u00a9e \"jeu\" d\u00c3\u00a9finie ci-dessous typedef struct{ int n; \/\/taille de la grille = n*n int valMax; \/\/ valeur \u00c3\u00a0 atteindre pour gagner int nbCasesLibres; \/\/nbre de cases libres sur la grille int score; \/\/score de la partie en cours int *grille; }jeu; La taille de la grille n'est pas fix\u00c3\u00a9e, d'o\u00c3\u00b9 l'utilisation d'une variable n et la n\u00c3\u00a9cessit\u00c3\u00a9 d'allouer la m\u00c3\u00a9moire de mani\u00c3\u00a8re dynamique. La fonction initialiseJeu permet de cr\u00c3\u00a9er la grille et d'initialiser ses variables. La fonction libereMemoire permet de lib\u00c3\u00a9rer la m\u00c3\u00a9moire r\u00c3\u00a9serv\u00c3\u00a9e pour l'utilisation de la grille. D'un point de vue conceptuel, la grille poss\u00c3\u00a8de 2 dimensions (des lignes et des colonnes) et est compos\u00c3\u00a9e de tuiles ayant une valeur variable. Pour faciliter l'acc\u00c3\u00a8s \u00c3\u00a0 ces valeurs, il est n\u00c3\u00a9cessaire de cr\u00c3\u00a9er les fonctions getVal et setVal. Les fonctions indiceValide et caseVide permettent des tests sur les tuiles de la grille. Les fonctions affichage et choixCouleur permettent d'afficher la grille sur le terminal Le code de ces fonctions est d\u00c3\u00a9fini dans le fichier grille.c . 1.2. Jouer au jeu Pour jouer au jeu, il est n\u00c3\u00a9cessaire de conna\u00c3\u00aetre les conditions de victoire et de d\u00c3\u00a9faite. Les fonctions gagne, perdu et finPartie permettent de tester ces conditions. La fonction ajouteValAlea permet d'ajouter une valeur sur la grille \u00c3\u00a0 chaque tour. La fonction jouer permet de jouer au jeu en lui m\u00c3\u00aame. Pour jouer au jeu, il est n\u00c3\u00a9cessaire de pouvoir en d\u00c3\u00a9placer les tuiles. Pour ce faire, l'utilisateur doit pouvoir int\u00c3\u00a9ragir avec le programme. Cette int\u00c3\u00a9raction se fait avec les touches du clavier. Le code de ces fonctions est d\u00c3\u00a9fini dans les fichiers partie.c et mouvement.c. 1.3. Sauvegarder et charger une partie Il ne serait pas pertinent de ne pas pouvoir reprendre une partie en cours si interruption du programme, d'o\u00c3\u00b9 la n\u00c3\u00a9cessit\u00c3\u00a9 d'ajouter des fonctionnalit\u00c3\u00a9s de sauvegarde\/chargement. Lors de la sauvegarde, les valeurs des variables d\u00c3\u00a9finissant la structure \"jeu\" sont enregistr\u00c3\u00a9es dans un fichier. Un fichier correspond \u00c3\u00a0 une sauvegarde de jeu (3 sauvegardes possibles).Les scores sont enregistr\u00c3\u00a9s dans un fichier s\u00c3\u00a9par\u00c3\u00a9. Pour que l'utilisateur ne puisse pas changer les valeurs des variables enregistr\u00c3\u00a9es et faire buguer le programme, les valeurs sont sauvegard\u00c3\u00a9es dans des fichiers binaires. L'utilisation d'un menu permet de faciliter la navigation entre les fonctionnalit\u00c3\u00a9s du programme. Le code de ces fonctions est d\u00c3\u00a9fini dans le fichier sauvegarde.c . 2 - R\u00c3\u00a9partition des t\u00c3\u00a2ches R\u00c3\u00a9alisation des fonctions du jeu : Tony Clonier R\u00c3\u00a9alisation de tous les tests unitaires : Steeve Jerent Cr\u00c3\u00a9ation de la documentation : Steeve Jerent et Tony Clonier","tags":"","url":"Manuel_technique\/Introduction.html"},{"title":"Grille","text":"Auteurs : Steeve Jerent - Tony Clonier 1 - Structure de donn\u00c3\u00a9es Jeu 2 - Fonction initialiseJeu 3 - Fonction LibereMemoire 4 - Fonction indiceValide 5 - Fonction getVal 6 - Fonction caseVide 7 - Fonction setVal 8 - Fonction suppl\u00c3\u00a9mentaire choixCouleur 9 - Fonction affichage Auteurs : Steeve Jerent - Tony Clonier 1 - Structure de donn\u00c3\u00a9es Jeu typedef struct{ int n; \/\/taille de la grille = n*n int valMax; \/\/ valeur \u00c3\u00a0 atteindre pour gagner int nbCasesLibres; \/\/nbre de cases libres sur la grille int score; \/\/score de la partie en cours int *grille; }jeu; 2 - Fonction initialiseJeu \/*! * Alloue la grille de la variable jeu pass\u00c3\u00a9e par adresse. * Initialise les cases de la grille avec des cases vides (valeur nulles) * Initialise les champs n et valMax avec les valeurs pass\u00c3\u00a9es en param\u00c3\u00a8tre * * \\param p : Pointeur sur une partie de 2048 * \\param n : Taille de la grille * \\param valMax : Valeur \u00c3\u00a0 atteindre pour gagner * *\/ void initialiseJeu(jeu *p, int n, int valMax){ \/\/Initialisation des variables p-&gt;n = n; p-&gt;nbCasesLibres = n*n; p-&gt;valMax = valMax; p-&gt;score = 0; \/\/allocation dynamique de la taille de la grille p-&gt;grille = (int*) malloc(p-&gt;nbCasesLibres*sizeof(int)); if(p-&gt;grille==NULL){ printf(&quot;Erreur allocation ! \\n&quot;); exit(-1); } \/\/Initialisation des cases de la grille \u00c3\u00a0 0 int i; for(i=0;i&lt;p-&gt;nbCasesLibres;i++) p-&gt;grille[i] = 0; } 3 - Fonction LibereMemoire \/*! * Lib\u00c3\u00a8re la m\u00c3\u00a9moire allouer pour la grille du jeu pass\u00c3\u00a9 par adresse. * * \\param p : pointeur sur la partie de 2048 *\/ void libereMemoire(jeu *p){ free(p-&gt;grille); } 4 - Fonction indiceValide \/*! * Fonction retournant 1 si la case (i, j) existe, 0 sinon. * * \\param p : Pointeur sur la partie de 2048 * \\param i : Ligne de la case cibl\u00c3\u00a9 * \\param j : colonne de la case cibl\u00c3\u00a9 *\/ int indiceValide(jeu *p, int i, int j){ \/\/les indices i et j doivent \u00c3\u00aatre compris entre 0 (inclus) et p-&gt;n (exclus) return (i&gt;=0 &amp;&amp; i &lt; p-&gt;n &amp;&amp; j&gt;=0 &amp;&amp; j &lt; p-&gt;n); } 5 - Fonction getVal \/*! * Fonction retournant la valeur de la case (ligne, colonne) de la partie p * ou -1 si la case n'existe pas. * * \\param p : pointeur sur la partie en cours * \\param ligne : entier correspondant au numero de ligne * \\param colonne : entier correspondant au num\u00c3\u00a9ro de colonne *\/ int getVal(jeu *p, int ligne, int colonne){ if(indiceValide(p, ligne, colonne)) return p-&gt;grille[p-&gt;n*ligne+colonne]; return -1; } 6 - Fonction caseVide \/*! * Retourne 1 si la case est vide, 0 sinon. * * \\param p : pointeur sur la partie en cours * \\param ligne : entier correspondant au numero de ligne * \\param colonne : entier correspondant au num\u00c3\u00a9ro de colonne *\/ int caseVide(jeu *p, int i, int j){ if(getVal(p, i, j)==0) return 1; return 0; } 7 - Fonction setVal \/*! * Fonction modifiant la valeur de la case (ligne, colonne) de la partie p, * avec la valeur val * * \\param p : pointeur sur la partie en cours * \\param ligne : entier correspondant au numero de ligne * \\param colonne : entier correspondant au num\u00c3\u00a9ro de colonne * \\param val : entier \u00c3\u00a0 mettre dans la case (i,j) (si elle existe) *\/ int setVal(jeu *p, int ligne, int colonne, int val){ \/\/ On verifie que l'indice est valide if(indiceValide(p, ligne, colonne)){ \/\/ si la valeur de la case est identique \u00c3\u00a0 val, on ne fait rien if(getVal(p, ligne, colonne) == val) return 0; \/\/si une ajoute une valeur \u00c3\u00a0 une case vide, on d\u00c3\u00a9cr\u00c3\u00a9mente le nombre de cases vides if(caseVide(p, ligne, colonne) &amp;&amp; val &gt; 0) p-&gt;nbCasesLibres--; \/\/si on vide une case, on incr\u00c3\u00a9mente le nombre de cases vides if(!caseVide(p, ligne, colonne) &amp;&amp; val == 0 ) p-&gt;nbCasesLibres++; \/\/modification de la valeur de la case p-&gt;grille[p-&gt;n*ligne+colonne] = val; return 1; } return 0; } 8 - Fonction suppl\u00c3\u00a9mentaire choixCouleur \/*! * Assigne une couleur a une case en fonction de la valeur n * Retourne la couleur correspondante * * \\param n : valeur de la case \u00c3\u00a0 colorer *\/ COULEUR_TERMINAL choixCouleur(int n){ COULEUR_TERMINAL couleur; switch(n){ case 0 : couleur = BLACK; break; case 2 : couleur = CYAN; break; case 4 : couleur = GREEN; break; case 8 : couleur = YELLOW; break; case 16 : couleur = BLUE; break; case 32 : couleur = RED; break; case 64 : couleur = CYAN; break; case 128 : couleur = GREEN; break; case 256 : couleur = YELLOW; break; case 512 : couleur = BLUE; break; case 1024 : couleur = RED; break; case 2048 : couleur = WHITE; break; default : couleur = CYAN; } return couleur; } 9 - Fonction affichage \/*! * Fonction affichant la grille \u00c3\u00a0 l'\u00c3\u00a9cran * * \\param p : pointeur sur la partie en cours. *\/ void affichage(jeu * p){ clear_terminal(); int val; \/\/boucles imbriqu\u00c3\u00a9es pour parcourir la grille int i; for(i=0;i&lt;p-&gt;n;i++){ \/\/Retour chariot \u00c3\u00a0 la fin d'une ligne printf(&quot;\\n&quot;); int j; for(j=0; j&lt;p-&gt;n; j++){ val = getVal(p, i, j); \/\/Si la case est vide on l'affiche int\u00c3\u00a9gralement en noir if(val == 0) color_printf(BLACK, BLACK, &quot; &quot;); \/\/sinon on appelle la fonction choixCouleur pour lui assigner une couleur else color_printf(WHITE, choixCouleur(val), &quot; %5d &quot;, val); } } printf(&quot;\\n&quot;); printf(&quot;Score : %d\\n\\n&quot;, p-&gt;score); if(gagne(p)) printf(&quot;Vous avez gagn\u00c3\u00a9 ! \\n\\n&quot;); else if(perdu(p)) printf(&quot;Vous avez perdu ! \\n\\n&quot;); }","tags":"","url":"Manuel_technique\/Grille.html"},{"title":"Partie","text":"Auteurs : Steeve Jerent - Tony Clonier 9 - Fonction ajoutValAlea 10 - Fonction gagne 11 - Fonction perdu 12 - Fonction finPartie 13 - Fonction jouer Auteurs : Steeve Jerent - Tony Clonier 9 - Fonction ajoutValAlea \/*! * Ajoute une valeur (2 ou 4 choisi al\u00c3\u00a9atoirement) sur une case vide * (elle aussi choisi aleatoirement) * * \\param p : pointeur sur la partie en cours *\/ void ajouteValAlea(jeu *p){ int ligne; int colonne; if(p-&gt;nbCasesLibres&gt;0){ \/\/On g\u00c3\u00a9n\u00c3\u00a8re des indices (ligne, colonne) jusqu'\u00c3\u00a0 tomber sur une case vide do{ ligne = rand()%p-&gt;n; colonne = rand()%p-&gt;n; }while(!caseVide(p, ligne, colonne)); \/\/ On assigne 2 ou 4 \u00c3\u00a0 la case s\u00c3\u00a9lectionn\u00c3\u00a9e if(rand()%2) setVal(p, ligne, colonne, 2); else setVal(p, ligne, colonne, 4); } } 10 - Fonction gagne \/*! * Retourne 1 si la partie est gagn\u00c3\u00a9e, 0 sinon. * * \\param p : Pointeur sur la partie en cours *\/ int gagne(jeu *p){ int flag = 0; int i = 0;\/\/ indice de ligne int j = 0;\/\/ indice de colonne \/\/boucles imbriqu\u00c3\u00a9es pour parcourir la grille while(i&lt;p-&gt;n &amp;&amp; flag==0){ j = 0; while(j&lt;p-&gt;n &amp;&amp; flag==0){ if(getVal(p, i, j)==p-&gt;valMax) flag = 1; j++; } i++; }\/\/sortie : grille enti\u00c3\u00a8rement parcourue ou une case de la grille a pour valeur p-&gt;valMax (flag==1) \/\/ flag==1 uniquement si une des cases de la grille a comme valeur p-&gt;valMax return flag; } 11 - Fonction perdu \/*! * Retourne 1 si la partie est perdu,0 sinon. * * \\param p : Pointeur sur la partie en cours *\/ int perdu(jeu *p){ \/\/S'il reste des cases libres, on n'a pas perdu if(p-&gt;nbCasesLibres&gt;0) return 0; int flag = 1; int i = 0; \/\/indice de ligne int j = 0;\/\/ indice de colonne \/\/Boucles imbriqu\u00c3\u00a9es pour parcourir la grille, on commence \u00c3\u00a0 la case (0,0) while(i&lt;p-&gt;n &amp;&amp; flag==1){ j = 0; while(j&lt;p-&gt;n &amp;&amp; flag==1){ \/\/ si on arrive \u00c3\u00a0 la derni\u00c3\u00a8re case de la grille, c'est qu'on a perdu if(i==p-&gt;n-1 &amp;&amp; j==p-&gt;n-1) flag = 1; \/\/ sinon on compare la case actuelle avec celle \u00c3\u00a0 droite et celle en dessous else if(getVal(p, i, j)==getVal(p, i+1, j) || getVal(p, i, j)==getVal(p, i, j+1)) flag = 0; j++; } i++; } \/* * sortie : grille enti\u00c3\u00a8rement parcourue (flag==1, on a perdu) ou * deux cases adjacentes ont les m\u00c3\u00aames valeurs (flag==0 i.e. on n'a pas encore perdu) *\/ return flag; } 12 - Fonction finPartie \/*! * Retourne 1 si la partie est termin\u00c3\u00a9, 0 sinon. * * \\param p : Pointeur sur la partie en cours *\/ int finPartie(jeu *p){ return (perdu(p) || gagne(p)); } 13 - Fonction jouer \/*! * Fonction permettant de jouer la partie en cours * (On la suppose initialis\u00c3\u00a9e) * Retourne 1 si la partie est termin\u00c3\u00a9e (gagn\u00c3\u00a9e ou perdu) * Retourne 0 sinon (L'utilisateur a appuy\u00c3\u00a9 sur la touche echap) * * \\param p : pointeur sur la partie en cours *\/ int jouer(jeu *p){ int saisie; int deplacement; \/\/ Test s'il y a eu un d\u00c3\u00a9placement affichage(p); printf(&quot;Utilisez les fl\u00c3\u00a8ches pour jouer \\n&quot;); printf(&quot;ECHAP : Acc\u00c3\u00a9der au menu \\n&quot;); do{ \/\/saisieD retourne -1, 1, 2, 3 ou 4 saisie = saisieD(); if(saisie&gt;=0){ deplacement = mouvement(p, saisie); if(deplacement) ajouteValAlea(p); affichage(p); printf(&quot;Utilisez les fl\u00c3\u00a8ches pour jouer \\n&quot;); printf(&quot;ECHAP : Acc\u00c3\u00a9der au menu \\n&quot;); } }while(saisie != -1 &amp;&amp; !finPartie(p)); \/\/On sort de la boucle si l'utilisateur appuie sur ECHAP ou si la partie est termin\u00c3\u00a9e \/\/Retourne -1 si l'utilisateur a appuy\u00c3\u00a9 sur ECHAP if(saisie==-1) return 0; \/\/Retourne 1 si la partie est termin\u00c3\u00a9e (perdu ou gagn\u00c3\u00a9) else return 1; }","tags":"","url":"Manuel_technique\/Partie.html"},{"title":"Mouvement","text":"Auteur : Tony Clonier 14 - Fonction mouvementLigne 15 - Fonction mouvementLignes 16 - Fonction mouvementColonne 17 - Fonction mouvementColonnes 18 - Fonction mouvement 19 - Fonction saisieD Auteur : Tony Clonier 14 - Fonction mouvementLigne \/*! * Effectue les mouvements (\u00c3\u00a0 gauche et \u00c3\u00a0 droite) des cases d'une ligne. * Renvoie 1 si l'on a d\u00c3\u00a9plac\u00c3\u00a9 au moins une case, 0 sinon * * \\param p : pointeur sur la partie en cours * \\param ligne : indice de ligne * \\param direction : 1 pour d\u00c3\u00a9placement vers la gauche, -1 pour d\u00c3\u00a9placement vers la droite *\/ int mouvementLigne(jeu *p, int ligne, int direction){ int colonne; int flag; int compteur = 0; \/\/Premi\u00c3\u00a8re boucle : tasser toutes les valeurs \u00c3\u00a0 droite ou \u00c3\u00a0 gauche do{ flag = 0; for(colonne=0;colonne&lt;p-&gt;n;colonne++){ \/\/Si la case actuelle est vide et la case adjacente (sur la ligne) a une valeur positive, on &quot;tasse&quot; if(getVal(p, ligne, colonne) == 0 &amp;&amp; getVal(p, ligne, colonne+direction) &gt; 0 ){ setVal(p, ligne, colonne, getVal(p, ligne, colonne+direction)); setVal(p, ligne, colonne+direction, 0); flag = 1; compteur++; } } }while(flag==1); \/\/sortie : Plus aucun mouvements \u00c3\u00a0 faire i.e. (flag==0) \/\/Deuxi\u00c3\u00a8me boucle : &quot;Fusionner&quot; les valeurs en double + retasser si besoin int depBoucle; if(direction==1) depBoucle = 0; else depBoucle = p-&gt;n-1; for(colonne=depBoucle; colonne&lt;p-&gt;n &amp;&amp; colonne&gt;=0; colonne+=direction){ \/\/Si la case actuelle \u00c3\u00a0 la m\u00c3\u00aame valeur qu'une case adjacente (sur la ligne), on &quot;fusionne&quot; les cases if(getVal(p, ligne, colonne) &gt; 0 &amp;&amp; getVal(p, ligne, colonne) == getVal(p, ligne, colonne+direction)){ p-&gt;score+=getVal(p, ligne, colonne); setVal(p, ligne, colonne, 2*getVal(p, ligne, colonne)); setVal(p, ligne, colonne+direction, 0); compteur++; \/\/Boucle interne permettant de retasser si &quot;fusion&quot; de cases int i; for(i=colonne; i&lt;p-&gt;n &amp;&amp; i&gt;=0; i+=direction){ if(getVal(p, ligne, i) == 0 &amp;&amp; getVal(p, ligne, i+direction) &gt; 0 ){ setVal(p, ligne, i, getVal(p, ligne, i+direction)); setVal(p, ligne, i+direction, 0); } } } } \/\/Retourne 1 si mouvement if(compteur &gt; 0) return 1; return 0; } 15 - Fonction mouvementLignes \/*! * Effectue les mouvements (\u00c3\u00a0 gauche et \u00c3\u00a0 droite) des cases sur toutes les lignes * Retoune 1 si l'on a d\u00c3\u00a9plac\u00c3\u00a9 au moins une case * Retourne 0 sinon * * \\param p : pointeur sur la partie en cours * \\param direction : 1 pour d\u00c3\u00a9placement vers la gauche, -1 pour d\u00c3\u00a9placement vers la droite *\/ int mouvementLignes(jeu *p, int direction){ int compteur = 0; int ligne; \/\/Boucle pour parcourir toutes les lignes for(ligne=0; ligne&lt;p-&gt;n; ligne++) compteur += mouvementLigne(p, ligne, direction); \/\/Retourne 1 si mouvement if(compteur&gt;0) return 1; return 0; } 16 - Fonction mouvementColonne \/*! * Effectue les mouvements (vers le haut ou vers le bas) des cases d'une colonne. * Renvoie 1 si l'on a d\u00c3\u00a9plac\u00c3\u00a9 au moins une case, 0 sinon * * \\param p : pointeur sur la partie en cours * \\param colonne : indice de colonne * \\param direction : 1 pour d\u00c3\u00a9placement vers le haut, -1 pour d\u00c3\u00a9placement vers le bas *\/ int mouvementColonne(jeu *p, int colonne, int direction){ int ligne; int flag; int compteur = 0; \/\/Premi\u00c3\u00a8re boucle : tasser toutes les valeurs en haut ou en bas do{ flag = 0; for(ligne=0;ligne&lt;p-&gt;n;ligne++){ \/\/Si la case actuelle est vide et la case adjacente (sur la colonne) a une valeur positive, on &quot;tasse&quot; if(getVal(p, ligne, colonne) == 0 &amp;&amp; getVal(p, ligne+direction, colonne) &gt; 0 ){ setVal(p, ligne, colonne, getVal(p, ligne+direction, colonne)); setVal(p, ligne+direction, colonne, 0); flag = 1; compteur++; } } }while(flag==1); \/\/sortie : Plus aucun mouvements \u00c3\u00a0 faire i.e. (flag==0) \/\/Deuxi\u00c3\u00a8me boucle : &quot;Fusionner&quot; les valeurs en double + retasser si besoin int depBoucle; if(direction==1) depBoucle = 0; else depBoucle = p-&gt;n-1; for(ligne=depBoucle; ligne&lt;p-&gt;n &amp;&amp; ligne&gt;=0; ligne+=direction){ \/\/Si la case actuelle \u00c3\u00a0 la m\u00c3\u00aame valeur qu'une case adjacente (sur la colonne), on &quot;fusionne&quot; les cases if(getVal(p, ligne, colonne) &gt; 0 &amp;&amp; getVal(p, ligne, colonne) == getVal(p, ligne+direction, colonne)){ p-&gt;score+=getVal(p, ligne, colonne); setVal(p, ligne, colonne, 2*getVal(p, ligne, colonne)); setVal(p, ligne+direction, colonne, 0); compteur++; int i; for(i=ligne; i&lt;p-&gt;n &amp;&amp; i&gt;=0; i+=direction){ \/\/Boucle interne permettant de retasser si &quot;fusion&quot; de cases if(getVal(p, i, colonne) == 0 &amp;&amp; getVal(p, i+direction, colonne) &gt; 0 ){ setVal(p, i, colonne, getVal(p, i+direction, colonne)); setVal(p, i+direction, colonne, 0); } } } } \/\/Retourne 1 si mouvement if(compteur &gt; 0) return 1; return 0; } 17 - Fonction mouvementColonnes \/*! * Effectue les mouvements (vers le haut ou vers le bas) des cases sur toutes les colonnes * Retoune 1 si l'on a d\u00c3\u00a9plac\u00c3\u00a9 au moins une case * Retourne 0 sinon * * \\param p : pointeur sur la partie en cours * \\param direction : 1 pour d\u00c3\u00a9placement vers le haut, -1 pour d\u00c3\u00a9placement vers le bas *\/ int mouvementColonnes(jeu *p, int direction){ int compteur = 0; int colonne; \/\/Boucle permettant de parcourir les colonnes for(colonne=0; colonne&lt;p-&gt;n; colonne++) compteur += mouvementColonne(p, colonne, direction); \/\/Retourne 1 si mouvement if(compteur&gt;0) return 1; return 0; } 18 - Fonction mouvement \/*! * Effectue le mouvement correspondant \u00c3\u00a0 la direction * Retourne 1 si on a d\u00c3\u00a9plac\u00c3\u00a9 au moins une case * Retourne 0 sinon * * \\param p : pointeur la partie en cours * \\param direction : entier donnant la direction : * 0 : vers le bas * 1 : vers la droite * 2 : vers le haut * 3 : vers la gauche *\/ int mouvement(jeu *p, int direction){ \/\/Pour tester s'il y a eu d\u00c3\u00a9placement int deplacement=0; \/\/Si 0, mouvement vers le bas if(direction==0) deplacement = mouvementColonnes(p, -1); \/\/Si 1, mouvement vers la droite else if(direction==1) deplacement = mouvementLignes(p, -1); \/\/Si 2, mouvement vers le haut else if(direction==2) deplacement = mouvementColonnes(p, 1); \/\/Si 3, mouvement vers la gauche else if(direction==3) deplacement = mouvementLignes(p, 1); \/\/Retourne 1 s'il y a eu d\u00c3\u00a9placement return deplacement; } 19 - Fonction saisieD \/*! * Fonction permettant la saisie d'une direction ou de l'arr\u00c3\u00aat du jeu * (saisie r\u00c3\u00a9p\u00c3\u00a9t\u00c3\u00a9e pour les autres touches) * *Retourne : * -1 : Si l'utilisateur arr\u00c3\u00aate le jeu * 0 : Si l'utilisateur souhaite d\u00c3\u00a9placer vers le BAS * 1 : Si l'utilisateur souhaite d\u00c3\u00a9placer vers le DROITE * 2 : Si l'utilisateur souhaite d\u00c3\u00a9placer vers le HAUT * 3 : Si l'utilisateur souhaite d\u00c3\u00a9placer vers le GAUCHE *\/ int saisieD(){ debutTerminalSansR(); Key touche;\/\/D\u00c3\u00a9finition d'une touche int saisie; \/\/On lit une fl\u00c3\u00a8che (ou la touche echap) do{ touche = lectureFleche(); }while(touche == NO_KEY); if(touche==KEY_ESCAPE) saisie = -1; if(touche==KEY_DOWN) saisie = 0; if(touche==KEY_RIGHT) saisie = 1; if(touche==KEY_UP) saisie = 2; if(touche==KEY_LEFT) saisie = 3; finTerminalSansR(); return saisie; }","tags":"","url":"Manuel_technique\/Mouvement.html"},{"title":"Sauvegarde","text":"Auteur : Tony Clonier 20 - Fonction sauvegardeJeu 21 - Fonction chargementJeu 22 - Fonction suppl\u00c3\u00a9mentaire sauvegardeScore 23 - Fonction suppl\u00c3\u00a9mentaire chargementScore 24 - Fonction menu Auteur : Tony Clonier 20 - Fonction sauvegardeJeu \/*! * Fonction sauvegardant la partie en cours * Retourne 0 en cas de probl\u00c3\u00a8me ou si l'utilisateur annule * Retourne 1 sinon * * \\param p : pointeur sur la partie en cours *\/ int sauvegardeJeu(jeu *p){ FILE *f; char nomF[80]; \/\/Stock le nom du fichier \u00c3\u00a0 sauvegarder char saisie; \/\/ 418 est la valeur max d\u00c3\u00a9di\u00c3\u00a9e pour lancer les tests if(p-&gt;valMax != 418){ \/\/On demande \u00c3\u00a0 l'utilisateur de choisir un slot de sauvegarde printf(&quot;Veuillez choisir un slot de sauvegarde [1\/2\/3] [0 pour annuler] \\n&quot;); do{ scanf(&quot;%c&quot;, &amp;saisie); }while(saisie!= '1' &amp;&amp; saisie!='2' &amp;&amp; saisie!='3' &amp;&amp; saisie!='0'); if(saisie=='0') return 0; \/\/Assigne un fichier \u00c3\u00a0 nomF en fonction du slot choisi if(saisie=='1') strcpy(nomF, &quot;.\/Saves\/Save1.bin&quot;); if(saisie=='2') strcpy(nomF, &quot;.\/Saves\/Save2.bin&quot;); if(saisie=='3') strcpy(nomF, &quot;.\/Saves\/Save3.bin&quot;); }else{ strcpy(nomF ,&quot;.\/Saves\/test_Iam_a_teampot.bin&quot;); } \/\/On test l'existance du fichier, s'il existe on demande \u00c3\u00a0 l'utilisateur s'il souhaite l'\u00c3\u00a9craser f = fopen(nomF, &quot;r&quot;); if(!(f==NULL)){ printf(&quot;Une sauvegarde existe d\u00c3\u00a9j\u00c3\u00a0, voulez vous l'\u00c3\u00a9craser ?[o\/n]\\n&quot;); do{ scanf(&quot;%c&quot;, &amp;saisie); }while(saisie!='o' &amp;&amp; saisie!='n' &amp;&amp; saisie!='O' &amp;&amp; saisie!='N'); \/\/S'il ne souhaite pas l'\u00c3\u00a9craser, on ferme le fichier et retourne 0 if(saisie=='n' || saisie=='N'){ fclose(f); return 0; } } \/\/Sinon on sauvegarde f = fopen(nomF, &quot;wb&quot;); if(f==NULL){ printf(&quot;Erreur de fopen \\n&quot;); return 0; } fwrite( &amp;p-&gt;n , sizeof(int) , 1 , f); fwrite( &amp;p-&gt;valMax , sizeof(int) , 1 , f); fwrite( &amp;p-&gt;nbCasesLibres , sizeof(int) , 1 , f); fwrite( &amp;p-&gt;score, sizeof(int), 1, f); fwrite( p-&gt;grille, sizeof(int), p-&gt;n*p-&gt;n, f); fclose(f); \/\/Retourne 1 si sauvegarde effectu\u00c3\u00a9e return 1; } 21 - Fonction chargementJeu \/*! * Fonction chargeant la derni\u00c3\u00a8re partie sauvegard\u00c3\u00a9e * Retourne 0 en cas de probl\u00c3\u00a8me et si la sauvegarde n'existe pas * Retourne 1 sinon * * \\param p : pointeur sur la partie en cours *\/ int chargementJeu(jeu *p){ FILE *f; char nomF[80]; char saisie; if(p-&gt;valMax != 418){ \/\/On demande \u00c3\u00a0 l'utilisateur quelle sauvegarde il souhaite charger printf(&quot;Veuillez choisir un slot de sauvegarde \u00c3\u00a0 charger [1\/2\/3] [0 pour annuler] \\n&quot;); do{ scanf(&quot;%c&quot;, &amp;saisie); }while(saisie!= '1' &amp;&amp; saisie!='2' &amp;&amp; saisie!='3' &amp;&amp; saisie!='0'); if(saisie=='0') return 0; \/\/Assigne un fichier \u00c3\u00a0 nomF en fonction du slot choisi if(saisie=='1') strcpy(nomF, &quot;.\/Saves\/Save1.bin&quot;); if(saisie=='2') strcpy(nomF, &quot;.\/Saves\/Save2.bin&quot;); if(saisie=='3') strcpy(nomF, &quot;.\/Saves\/Save3.bin&quot;); }else{ strcpy(nomF, &quot;.\/Saves\/test_Iam_a_teampot.bin&quot;); } \/\/On test l'existance du fichier, s'il n'existe pas on retourne 0 f = fopen(nomF, &quot;rb&quot;); if(f==NULL) return 0; \/\/Sinon on charge la sauvegarde fread( &amp;p-&gt;n , sizeof(int) , 1 , f); fread( &amp;p-&gt;valMax , sizeof(int) , 1 , f); fread( &amp;p-&gt;nbCasesLibres , sizeof(int) , 1 , f); fread( &amp;p-&gt;score, sizeof(int), 1, f); \/\/On refait une allocation de la grille, dont la taille peut avoir chang\u00c3\u00a9e p-&gt;grille = (int*)malloc((p-&gt;n*p-&gt;n)*sizeof(int)); if(p-&gt;grille==NULL){ printf(&quot;Erreur allocation ! \\n&quot;); exit(-1); } fread(p-&gt;grille, sizeof(int), p-&gt;n*p-&gt;n, f); fclose(f); \/\/Retourne 1 si chargement effectu\u00c3\u00a9 return 1; } 22 - Fonction suppl\u00c3\u00a9mentaire sauvegardeScore \/*! * Fonction sauvegardant un score * Retourne 0 en cas de probl\u00c3\u00a8me * Retourne 1 sinon * * \\param score : score \u00c3\u00a0 enregistrer *\/ int sauvegardeScore(int score){ FILE *f; char nom[20];\/\/Pour stocker le nom du jouer f = fopen(&quot;.\/Saves\/score.bin&quot;, &quot;ab&quot;); if(f==NULL) return 0; \/\/L'utilisateur peut saisir son nom ou annuler l'enregistrement de son score printf(&quot;Nom du joueur ? [0 pour annuler] \\n&quot;); scanf(&quot;%s&quot;, nom); if(nom[0]=='0') return 0; \/\/Sauvegarde de son score fwrite(nom, sizeof(nom), 1, f); fwrite( &amp;score, sizeof(int), 1, f); fclose(f); \/\/Retourne 1 si sauvegarde effectu\u00c3\u00a9e return 1; } 23 - Fonction suppl\u00c3\u00a9mentaire chargementScore \/*! * Fonction chargeant la liste des scores * Retourne 0 en cas de probl\u00c3\u00a8me * Retourne 1 sinon * * \\param score : score \u00c3\u00a0 enregistrer *\/ int chargementScore(){ FILE *f; char nom[20];\/\/Pour afficher le nom int score;\/\/Pour afficher le score f = fopen(&quot;.\/Saves\/score.bin&quot;, &quot;rb&quot;); if(f==NULL) return 0; \/\/On parcourt le fichier et affiche les noms et scores des joueurs printf(&quot;Scores : \\n&quot;); while(fread( nom, sizeof(nom), 1, f)==1 &amp;&amp; fread( &amp;score, sizeof(int), 1, f)==1) printf(&quot;%s : %d\\n&quot;, nom, score); printf(&quot;\\n&quot;); fclose(f); \/\/Retourne 1 si score charg\u00c3\u00a9 return 1; } 24 - Fonction menu \/*! * Affiche le menu : * 1 - Cr\u00c3\u00a9er nouvelle partie * 2 - Jouer * 3 - Sauvegarder * 4 - Charger * 5 _ Afficher scores * 6 - Quitter * Retourne la valeur saisie par l'utilisateur *\/ int menu(){ int choix; printf(&quot;\\n&quot;); printf(&quot;1 - Cr\u00c3\u00a9er nouvelle partie \\n&quot;); printf(&quot;2 - Jouer \\n&quot;); printf(&quot;3 - Sauvegarder \\n&quot;); printf(&quot;4 - Charger \\n&quot;); printf(&quot;5 - Afficher scores \\n&quot;); printf(&quot;6 - Quitter \\n&quot;); printf(&quot;\\n&quot;); do{ scanf(&quot;%d&quot;, &amp;choix); }while(choix!=1 &amp;&amp; choix!=2 &amp;&amp; choix!=3 &amp;&amp; choix!=4 &amp;&amp; choix!=5 &amp;&amp; choix!=6); return choix; }","tags":"","url":"Manuel_technique\/Sauvegarde.html"},{"title":"Test grille","text":"Auteur : Jerent Steeve 1 - Fonction termine 2 - Fonction int test_creer_initialiseJeu 3 - Fonction test_indice_valide 4 - Fonction test_fonction_get_val 5 - Fonction test_fonction_set_val 6 - Fonction test_partie1 Source Auteur : Jerent Steeve 1 - Fonction termine Permet d'afficher les messages d'erreurs lors des tests unitaires et retourne 0 pour signaler l'erreur. int termine(const char *ch){ printf(&quot;\\033[31;01m***********************\\n&quot;); printf(&quot;******* Erreur ********\\n&quot;); printf(&quot;***********************\\n&quot;); printf(&quot;* %s *\\033[00m\\n&quot;, ch); return 0; } 2 - Fonction int test_creer_initialiseJeu Cas de test : Test de la valeur max : On v\u00c3\u00a9rifie si la valeur max est \u00c3\u00a9gale \u00c3\u00a0 donn\u00c3\u00a9e dans la norme. Test du nombre de cases libres : Apr\u00c3\u00a8s initialisation de la partie on v\u00c3\u00a9rifie si nbCaseLibre est \u00c3\u00a9gale \u00c3\u00a0 n*n. On r\u00c3\u00a9alise une seconde v\u00c3\u00a9rification, en faisant la somme des valeurs composant la grille pour d\u00c3\u00a9terminer si elle vaut 0 int test_creer_initialiseJeu(){ int i; int n = 4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); if(tmp-&gt;valMax != vMax) return termine(&quot;La valeur maximun \u00c3\u00a0 atteindre n'est pas correcte ! &quot;); if(tmp-&gt;nbCasesLibres != n*n) return termine(&quot;Le nombre de case libre n'est pas correct !&quot;); int somme = 0; for(i=0; i&lt;n*n; i++) somme+=tmp-&gt;grille[i]; if(somme != 0) return termine(&quot;La grille ne contient pas que des cases libres !&quot;); libereMemoire(tmp); return 1; } 3 - Fonction test_indice_valide Cas de test : Test indice case : On cumule chaque indice valide de notre grille et on v\u00c3\u00a9rifie si sa taille est \u00c3\u00a9gale \u00c3\u00a0 n*n. Puis nous r\u00c3\u00a9alisons des tests si l'indice est hors des limites de la grille int test_indice_valide(){ int n=4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp ,n,vMax); int i,j; int somme = 0; for(i = 0 ; i &lt; n ; i++) for(j = 0 ; j &lt;n ; j++) somme += indiceValide(tmp,i,j); if (somme != n*n) return termine(&quot;indice =Valide ne retourne pas 1 correctement&quot;); if(indiceValide(tmp,-1,2) || indiceValide(tmp,n,2)) return termine(&quot;indiceValide ne retourne pas 0 correctement !&quot;); if(indiceValide(tmp,3,-1) || indiceValide(tmp,3,n)) return termine(&quot;indiceValide ne retourne pas 0 correctement !&quot;); libereMemoire(tmp); return 1; } 4 - Fonction test_fonction_get_val Cas de tests : Test valeur case : On remplit une grille de jeu avec des valeurs puis on v\u00c3\u00a9rifie la somme des valeurs de la grille int test_fonction_get_val(){ int n=6; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp,n,vMax); int i,j; int somme = 0; for(i = -1 ; i &lt;= n ; i++) for(j = -1 ; j &lt;= n ; j++) somme += getVal(tmp,i,j); if (somme != -28) return termine(&quot;La case n'est pas vide ou getVal ne retourne pas -1 quand on n'est pas sur la case&quot;); for(i = 7 ; i &lt;= 10 ; i++) tmp-&gt;grille[i] = i -6; somme=0; for(i=0; i&lt;=5;i++) for(j=0; j&lt;=5; j++) somme += getVal(tmp, i, j); if (somme != 10) return termine(&quot;getVal ne retourne pas la bonne valeur !&quot;); libereMemoire(tmp); return 1; } 5 - Fonction test_fonction_set_val Cas de test : Test set valeur : On set les valeurs de plusieurs cases et on test si la fonction \"setVal\" renvoie 1. Test nbCasesLibres : On v\u00c3\u00a9rifie si le nombre de cases libres s'incr\u00c3\u00a9mente ou d\u00c3\u00a9cr\u00c3\u00a9mente en fonction de la valeur \u00c3\u00a0 mettre dans la case. 0 - incr\u00c3\u00a9mente sup. 0 - d\u00c3\u00a9cr\u00c3\u00a9mente int test_fonction_set_val(){ int n=6; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp,n,vMax); int res = setVal(tmp, 1,1,5); if(res != 1) return termine(&quot;set valeur ne retourne pas la bonne valeur !&quot;); if(tmp-&gt;nbCasesLibres != 35) return termine(&quot;Le nombre de case libre n'est pas correct ! test&quot;); if(tmp-&gt;grille[7] != 5) return termine(&quot;setVal ne modifie pas correctement la case !&quot;); res = setVal(tmp, 18,2,5); if(res != 0) return termine(&quot;setVAl ne renvoie pas la bonne valeur ! L'indice de ligne n'est pas bon !&quot;); res = setVal(tmp, -1,2,7); if(res != 0) return termine(&quot;setVAl ne renvoie pas la bonne valeur ! L'indice de ligne n'est pas bon !&quot;); res = setVal(tmp, 0, 2, 3); if(res != 1) return termine(&quot;setVal ne renvoie pas la bonne valeur !&quot;); if(tmp-&gt;nbCasesLibres != 34) return termine(&quot;Le nombre de case libre n'est pas correcte ! On modifie la bordure !&quot;); if (tmp-&gt;grille[2] != 3) return termine(&quot;setVal ne modifie pas correctement la valeur !&quot;); res = setVal(tmp, 1,1,3); if (res != 1) return termine(&quot;setVal ne renvoie pas la bonne valeur !&quot;); if (tmp-&gt;nbCasesLibres != 34) return termine(&quot;le nombre de case libre n'est pas correct !&quot;); if(tmp-&gt;grille[7] != 3) return termine(&quot;setVal ne modifie pas correctement le jeu !&quot;); res = setVal(tmp, 1,1,0); if (res != 1) return termine(&quot;set valeur ne renvoie pas la bonne valeur !&quot;); if (tmp-&gt;nbCasesLibres != 35) return termine(&quot;le nombre de cases de libres n'est pas correct !&quot;); if (tmp-&gt;grille[7] != 0) return termine(&quot;setVal ne modifie pas correctement le jeu !&quot;); libereMemoire(tmp); return 1; } 6 - Fonction test_partie1 Permet de caculer le score des tests r\u00c3\u00a9alis\u00c3\u00a9s lors de cette partie, afin de valider les fonctions utilis\u00c3\u00a9es. void test_partie1(){ int somme = 0; somme += test_creer_initialiseJeu(); somme += test_indice_valide(); somme += test_fonction_get_val(); somme += test_fonction_set_val(); if(somme != 4) termine(&quot;TOUS LES TESTS DE LA PARTIE 1 NE SONT PAS PASSES !&quot;); else{ printf(&quot;\\033[32;01m#########################\\n&quot;); printf(&quot;# TESTS PARTIE 1 OK #\\n&quot;); printf(&quot;#########################\\033[00m\\n&quot;); } } Source Document de test de la grille du jeu 2048 fourni par monsieur B. KHAFIF.","tags":"","url":"Tests_unitaires\/Test_grille.html"},{"title":"Test partie","text":"Auteur : Jerent Steeve 1 - Fonction test_case_vide 2 - Fonction test_ajouter_val_aleatoire 3 - Fonction test_gagne 4 - Fonction test_perdu 5 - Fonction test_finPartie 6 - Fonction test_partie2 Auteur : Jerent Steeve 1 - Fonction test_case_vide Cas de test : Test case : On test une case remplie dans la grille puis une vide. Test case hors grille : On test une case hors de la grille. la fonction caseVide doit retourner 0. Test case grille remplie totalement : On fait la somme des cases remplies dans le tableau et on compare \u00c3\u00a0 n*n (taille de la grille) Test case grille vide : On fait la somme des cases vides dans le tableau et on compare \u00c3\u00a0 n*n (taille de la grille) int test_case_vide(){ int i, j; int n = 4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); setVal(tmp, 1, 3, 5); int res = caseVide(tmp, 1, 3); if(res != 0) return termine(&quot;La case est vide.&quot;); setVal(tmp, 1, 3, 0); res = caseVide(tmp, 1, 3); if(res != 1) return termine(&quot;La case n'est pas vide.&quot;); res = caseVide(tmp, 9, 9); if(res != 0) return termine(&quot;La case n'existe pas.&quot;); for(i=0; i&lt;=n;i++) for(j=0; j&lt;=n; j++) setVal(tmp, i, j, 1); int somme = 0; for(i=0; i&lt;n;i++) for(j=0; j&lt;n; j++) somme += caseVide(tmp, i, j); if(somme != 0) return termine(&quot;Une case ou plusieurs cases du tableau ne sont pas vides&quot;); for(i=0; i&lt;=n;i++) for(j=0; j&lt;=n; j++) setVal(tmp, i, j, 0); somme = 0; for(i=0; i&lt;n;i++) for(j=0; j&lt;n; j++) somme += caseVide(tmp, i, j); if (somme != 16) return termine(&quot;Une case ou plusieurs cases sont remplies&quot;); libereMemoire(tmp); return 1; } 2 - Fonction test_ajouter_val_aleatoire Cas de test : Test ajout valeur al\u00c3\u00a9atoire : On utilise la fonction ajoutValAlea puis on v\u00c3\u00a9rifie dans la grille si elle a bien \u00c3\u00a9t\u00c3\u00a9 cr\u00c3\u00a9\u00c3\u00a9e. On v\u00c3\u00a9rifie ensuite si elle a cr\u00c3\u00a9\u00c3\u00a9 plusieurs valeurs aleatoires dans la grille. 2. Test ajout de 2 ou 4 : On test si la fonction affectent les bonnes valeurs (2 ou 4). Si le nombre d'essai d\u00c3\u00a9passe 1000 ou s'l ne trouve qu'une des deux valeurs, on envoie une erreur 3. Test apparition al\u00c3\u00a9atoire: On v\u00c3\u00a9rifie que les valeurs al\u00c3\u00a9atoires n'apparaissent pas sur la m\u00c3\u00aame case. Test grille remplie: On v\u00c3\u00a9rifie qu'aucune valeur n'est entr\u00c3\u00a9e dans une grille remplie. int test_ajouter_val_aleatoire(){ int i, j; int n = 4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); ajouteValAlea(tmp); int compteur = 0; for(i=0; i&lt;n;i++){ for(j=0; j&lt;n; j++){ if(getVal(tmp, i, j) == 2 || getVal(tmp, i, j) == 4){ compteur++; setVal(tmp, i, j, 0); } } } if(compteur == 0) return termine(&quot;Aucune valeur aleatoire n'as \u00c3\u00a9t\u00c3\u00a9 rajout\u00c3\u00a9e.&quot;); if(compteur &gt; 1) return termine(&quot;Plusieurs valeurs aleatoires ont \u00c3\u00a9t\u00c3\u00a9 trouv\u00c3\u00a9es.&quot;); int l = 0; int nb_2 = 0; int nb_4 = 0; while(l&lt;1000 &amp;&amp; (nb_2 == 0 || nb_4 == 0)){ ajouteValAlea(tmp); for(i=0; i&lt;n;i++){ for(j=0; j&lt;n; j++){ if(getVal(tmp, i, j) == 2){ nb_2++; setVal(tmp, i, j, 0); }else if(getVal(tmp, i, j) == 4){ nb_4++; setVal(tmp, i, j, 0); } } } l++; } if(nb_2 == 0 || nb_4 == 0) return termine(&quot;L'une des 2 valeurs aleatoires est manquante.&quot;); int case_alea = 0; int pos_ligne = -1, pos_colonne=-1; l=0; while(l&lt;10){ ajouteValAlea(tmp); for(i=0; i&lt;n;i++){ for(j=0; j&lt;n; j++){ if(getVal(tmp, i, j) == 2 || getVal(tmp, i, j) == 4){ if(i != pos_ligne &amp;&amp; j != pos_colonne){ pos_ligne = i; pos_colonne = j; setVal(tmp, i, j, 0); case_alea--; }else{ case_alea++; setVal(tmp, i, j, 0); } } } } l++; } if(case_alea == 10) return termine(&quot;Les valeur 2 et 4 n'apparaissent pas al\u00c3\u00a9atoirement.'&quot;); for(i=0; i&lt;=n;i++) for(j=0; j&lt;=n; j++) setVal(tmp, i, j, 1); ajouteValAlea(tmp); compteur=0; for(i=0; i&lt;n;i++){ for(j=0; j&lt;n; j++){ if(getVal(tmp, i, j) == 2 || getVal(tmp, i, j) == 4){ compteur++; setVal(tmp, i, j, 0); } } } if(compteur != 0) return termine(&quot;Un valeur a \u00c3\u00a9t\u00c3\u00a9 rajout\u00c3\u00a9e aleatoirement alors que la grille est remplie&quot;); libereMemoire(tmp); return 1; } 3 - Fonction test_gagne Cas de test : On v\u00c3\u00a9rifie que la fonction gagne retourne 1 quand la valeur vMax est atteinte, sinon 0. int test_gagne(){ int n = 4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); \/\/ Si la valeur est \u00c3\u00a9gale \u00c3\u00a0 vMax setVal(tmp, 1,1, 2048); int res = gagne(tmp); if(res != 1) return termine(&quot;La valeurs set devaient permettre de gagner.&quot;); \/\/ si la valeur est inf\u00c3\u00a9rieure \u00c3\u00a0 vMax setVal(tmp, 1,1, 1024); res = gagne(tmp); if(res != 0) return termine(&quot;La valeur 2048 a \u00c3\u00a9t\u00c3\u00a9 modifi\u00c3\u00a9e par 1024, donc il est impossible de gagner.&quot;); \/\/ Si la valeur est strictement sup\u00c3\u00a9rieure \u00c3\u00a0 vMax setVal(tmp, 1, 1, 2049); res = gagne(tmp); if(res != 1) return termine(&quot;La valeurs set devaient permettre de gagner.&quot;); libereMemoire(tmp); return 1; } 4 - Fonction test_perdu Cas de test : On v\u00c3\u00a9rifie que la fonction perdu retourne 1 quand aucun mouvement n'est possible, sinon 0. int test_perdu(){ int n = 2; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); setVal(tmp, 0, 0, 1); setVal(tmp, 0, 1, 2); setVal(tmp, 1, 0, 3); setVal(tmp, 1, 1, 4); int res = perdu(tmp); if(res != 1) return termine(&quot;La partie devrait \u00c3\u00aatre perdue&quot;); setVal(tmp, 1, 1, 2); res = perdu(tmp); if(res != 0) return termine(&quot;1 - La partie devrait continuer&quot;); setVal(tmp, 0, 0, 2); setVal(tmp, 0, 1, 4); setVal(tmp, 1, 1, 4); res = perdu(tmp); if(res != 0) return termine(&quot;2 - La partie devrait continuer&quot;); libereMemoire(tmp); return 1; } 5 - Fonction test_finPartie Cas de test On set la valeur max dans la grille On remplace la valeur max ajout\u00c3\u00a9e par une valeur inf\u00c3\u00a9rieure \u00c3\u00a0 vMax On fini de remplir la grille afin que l'utilisateur ne puisse pas effectuer de mouvement int test_finPartie(){ int n = 2; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); setVal(tmp, 1, 1, 2048); int res = finPartie(tmp); if(res != 1) return termine(&quot;La partie devrait \u00c3\u00aatre fini.&quot;); setVal(tmp, 1, 1, 1024); res = finPartie(tmp); if (res != 0) return termine(&quot;La partie est encore jouable.&quot;); setVal(tmp, 0, 0, 1025); setVal(tmp, 1, 0, 1022); setVal(tmp, 0, 1, 1023); res = finPartie(tmp); if (res != 1) return termine(&quot;La partie n'est plus jouable.&quot;); libereMemoire(tmp); return 1; } 6 - Fonction test_partie2 On calcule la somme des tests de la partie 2. void test_partie2(){ int somme = 0; somme += test_case_vide(); somme += test_ajouter_val_aleatoire(); somme += test_gagne(); somme += test_perdu(); somme += test_finPartie(); if(somme != 5) termine(&quot;TOUS LES TESTS DE LA PARTIE 2 NE SONT PAS PASSES !&quot;); else{ printf(&quot;\\033[32;01m#########################\\n&quot;); printf(&quot;# TESTS PARTIE 2 OK #\\n&quot;); printf(&quot;#########################\\033[00m\\n&quot;); } }","tags":"","url":"Tests_unitaires\/Test_partie.html"},{"title":"Test mouvement","text":"Auteur : Jerent Steeve 1 - Fonction test_mouvementLigne 2 - Fonction test_mouvementLignes 3 - Fonction test_mouvementColonne 4 - Fonction test_mouvementColonnes 5 - Fonction test_mouvement 6 - Fonction test_saisieD 7 - Fonction test_jouer 8 - Fonction test_partie3 Auteur : Jerent Steeve 1 - Fonction test_mouvementLigne int test_mouvementLigne(){ \/\/ initialisation d'une partie int n = 4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); \/\/ On test un mouvement vers la droite impossible car on sortirait de la grille setVal(tmp, 0, 3, 2); int res = mouvementLigne(tmp, 0, -1); if (res != 0) return termine(&quot;ml - Le mouvement vers la droite \u00c3\u00a0 \u00c3\u00a9t\u00c3\u00a9 execut\u00c3\u00a9&quot;); \/\/ On test si le mouvement vers la gauche peut \u00c3\u00aatre r\u00c3\u00a9alis\u00c3\u00a9 et si la valeur de la \/\/ case pr\u00c3\u00a9c\u00c3\u00a9dente est reinitialis\u00c3\u00a9e. res = mouvementLigne(tmp, 0, 1); if(getVal(tmp, 0, 0) == 0) return termine(&quot;ml - Le mouvement sur la ligne est incorrect.&quot;); if (res != 1) return termine (&quot;ml - Le mouvement n'as pas \u00c3\u00a9t\u00c3\u00a9 execut\u00c3\u00a9.&quot;); \/\/ On rempli le tableau de mani\u00c3\u00a8re \u00c3\u00a0 ce que les valeurs ne puissent pas \u00c3\u00aatre boug\u00c3\u00a9es setVal(tmp, 0, 1, 32); setVal(tmp, 0, 2, 4); setVal(tmp, 0, 3, 2); res = mouvementLigne(tmp, 0, -1); if(res != 0) return termine(&quot;ml - Le mouvement vers la droite \u00c3\u00a0 \u00c3\u00a9t\u00c3\u00a9 effectu\u00c3\u00a9.&quot;); res = mouvementLigne(tmp, 0, 1); if(res != 0) return termine(&quot;ml - Le mouvement vers la gauche \u00c3\u00a0 \u00c3\u00a9t\u00c3\u00a9 effectu\u00c3\u00a9.&quot;); \/\/ on set la case [0,3] \u00c3\u00a0 4 afin de fusionner cet \u00c3\u00a9l\u00c3\u00a9ment avec la case [0,4] \/\/ qui contient 4 lors du mouvement de la ligne 0, on testera la case pr\u00c3\u00a9c\u00c3\u00a9dente afin \/\/ de v\u00c3\u00a9rifier si elle est r\u00c3\u00a9initialis\u00c3\u00a9e et que la nouvelle case vaut 8, on testera aussi \/\/ que le mouvement est effectu\u00c3\u00a9 setVal(tmp, 0, 3, 4); res = mouvementLigne(tmp, 0, -1); if(getVal(tmp, 0, 3) != 8) return termine(&quot;ml - La dernier case [0, 3] n'est pas \u00c3\u00a9gale \u00c3\u00a0 8&quot;); if(getVal(tmp, 0, 0) != 0) return termine(&quot;ml - La valeur de la case [0,0] n'est pas reinitialis\u00c3\u00a9e.&quot;); if(res != 1) return termine(&quot;ml - Le mouvement vers la droite n'a pas \u00c3\u00a9t\u00c3\u00a9 effectu\u00c3\u00a9.&quot;); \/\/ on modifie la valeur de la case [0,0] \u00c3\u00a0 2, et on effectue un mouvement vers la gauche \/\/ on v\u00c3\u00a9rifie la valeur de la case [0,0] si elle vaut 4 et si la case [0,3] setVal(tmp, 0, 0, 2); res = mouvementLigne(tmp, 0, 1); if(getVal(tmp, 0, 0) != 4) return termine(&quot;ml - La valeur de la case [0,0] n'est pas \u00c3\u00a9gale \u00c3\u00a0 4&quot;); if(getVal(tmp, 0, 3) != 0) return termine(&quot;ml - La valeur de la case [0,3] n'est pas r\u00c3\u00a9initialis\u00c3\u00a9e.&quot;); \/\/ On modifie des valeurs sur la ligne 0. pour tester encore la fusion des cases si similaires setVal(tmp, 0, 2, 32); setVal(tmp, 0, 3, 64); res = mouvementLigne(tmp, 0, -1); if(getVal(tmp, 0, 2) != 64) return termine(&quot;ml - La valeur de la case [0,2] n'est pas \u00c3\u00a9gale \u00c3\u00a0 64.&quot;); if(getVal(tmp, 0, 3) != 64) return termine(&quot;ml - La valeur de la case [0,3] n'est pas \u00c3\u00a9gale \u00c3\u00a0 64.&quot;); return 1; } 2 - Fonction test_mouvementLignes int test_mouvementLignes(){ int n = 2; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); setVal(tmp, 0, 1, 2); setVal(tmp, 1, 1, 2); \/\/ Test mouvement vers la Droite de toutes les lignes int res = mouvementLignes(tmp, -1); if(res != 0) return termine(&quot;mls - Le mouvement sur les lignes est effectu\u00c3\u00a9.&quot;); \/\/ Test mouvement vers la Gauche de toutes les lignes res = mouvementLignes(tmp, 1); if(res != 1) return termine(&quot;mls - 1 - Le mouvement sur les lignes n'est pas effectu\u00c3\u00a9.&quot;); \/\/ on set les m\u00c3\u00aames valeurs dans toutes les cases et on r\u00c3\u00a9alise un test \/\/ vers la droite, en verifiant si les bonnes valeurs sont assign\u00c3\u00a9es dans la grille. setVal(tmp, 0, 1, 2); setVal(tmp, 1, 1, 2); res = mouvementLignes(tmp, -1); if(res != 1) return termine(&quot;mls - 2 - Le mouvement sur les lignes n'est pas \u00c3\u00a9t\u00c3\u00a9 effectu\u00c3\u00a9.&quot;); if(getVal(tmp, 0, 1) != 4 || getVal(tmp, 1, 1) != 4) return termine(&quot;mls - Le mouvement n'a pas donn\u00c3\u00a9 4 sur les cases [0,1] ou [1,1]&quot;); if(getVal(tmp, 1, 0) != 0 || getVal(tmp, 0, 0) != 0) return termine(&quot;mls - Le mouvement n'a pas donn\u00c3\u00a9 4 sur les cases [0,1] ou [1,1]&quot;); \/\/ On refait un mouvement vers la droite apr\u00c3\u00a8s avoir r\u00c3\u00a9alis\u00c3\u00a9 le test pr\u00c3\u00a9cedent et avoir modifi\u00c3\u00a9 la ligne du bas. setVal(tmp, 1, 1, 0); setVal(tmp, 1, 0, 2); res = mouvementLignes(tmp, -1); if(res != 1) return termine(&quot;mls - Aucun mouvement vers la droite detect\u00c3\u00a9.&quot;); return 1; } 3 - Fonction test_mouvementColonne int test_mouvementColonne(){ int n = 2; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); setVal(tmp, 0, 0, 2); setVal(tmp, 1, 1, 2); \/\/ On effectue un mouvement vers le bas pour la colonne 1 (impossible) int res = mouvementColonne(tmp, 1, -1); if(res != 0) return termine(&quot;mc - 1 - Aucune case ne devrait bouger.&quot;); \/\/ On effectue un mouvement vers le haut pour la colonne 0 (impossible) res = mouvementColonne(tmp, 0, 1); if(res != 0) return termine(&quot;mc - 2 - Aucune case ne devrait bouger.&quot;); \/\/ On remplit la grille et on fait un mouvement vers le haut pour la colonne 1, \/\/ puis on v\u00c3\u00a9rifie les valeurs puis on refait la m\u00c3\u00aame exp\u00c3\u00a9rience avec la colonne 0 que l'on \/\/ fait descendre. setVal(tmp, 0, 1, 2); setVal(tmp, 1, 0, 2); res = mouvementColonne(tmp, 1, 1); if(res != 1) return termine(&quot;mc - 1 - Aucune case n'a boug\u00c3\u00a9&quot;); if (getVal(tmp, 0, 1) != 4) return termine(&quot;mc - La valeur de la case [0,1] devrait \u00c3\u00aatre \u00c3\u00a9gale \u00c3\u00a0 4&quot;); if(getVal(tmp, 1, 1) != 0) return termine(&quot;mc - La valeur de la case [1,1] n'a pas \u00c3\u00a9t\u00c3\u00a9 reinitialis\u00c3\u00a9e.&quot;); res = mouvementColonne(tmp, 0, -1); if(res != 1) return termine(&quot;mc - 2 - Aucune case n'a boug\u00c3\u00a9.&quot;); if(getVal(tmp, 1, 0) != 4) return termine(&quot;mc - La valeur de la case [1,0] devrait \u00c3\u00aatre \u00c3\u00a9gale \u00c3\u00a0 4&quot;); if(getVal(tmp, 0, 0) != 0) return termine(&quot;mc - La valeur de la case [0,0] n'a pas \u00c3\u00a9t\u00c3\u00a9 reinitialis\u00c3\u00a9e.&quot;); \/\/ On test si 2 valeurs differentes vont fusionner lors d'un mouvement et on v\u00c3\u00a9rifie les valeurs des cases setVal(tmp, 0,0, 32); res = mouvementColonne(tmp, 0, 1); if(res != 0) return termine(&quot;mc - Le mouvement effectu\u00c3\u00a9 est interdit.&quot;); if(getVal(tmp, 0, 0) != 32) return termine(&quot;mc - La valeur de la case [0,0] \u00c3\u00a0 \u00c3\u00a9t\u00c3\u00a9 chang\u00c3\u00a9e.&quot;); return 1; } 4 - Fonction test_mouvementColonnes int test_mouvementColonnes(){ int n = 2; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); \/\/ On ajoute des valeurs sur la ligne du bas de la grille \/\/ on r\u00c3\u00a9alise un mouvement vers le haut puis le bas. setVal(tmp, 0, 1, 2); setVal(tmp, 1, 0, 2); int res = mouvementColonnes(tmp, 1); if(res != 1) return termine(&quot;mcs - 1 - Aucune case n'a boug\u00c3\u00a9.&quot;); res = mouvementColonnes(tmp, -1); if(res != 1) return termine(&quot;mcs - 2 - Aucune case n'a boug\u00c3\u00a9.&quot;); \/\/ on test si on peut sortir de la grille avec les mouvement vers le HAUT \/\/ et BAS res = mouvementColonnes(tmp, -1); if(res != 0) return termine(&quot;mcs - 1 - Aucune case ne devait bouger.&quot;); mouvementColonnes(tmp, 1); res = mouvementColonnes(tmp, 1); if(res != 0) return termine(&quot;mcs - 2 - Aucune case ne devait bouger.&quot;); \/\/ On modifie les valeur de la grille pour emp\u00c3\u00aacher les mouvements setVal(tmp, 1, 0, 2); setVal(tmp, 1, 1, 4); res = mouvementColonnes(tmp, -1); if(res != 1) return termine(&quot;mcs - 3 - Aucune case n'a boug\u00c3\u00a9.&quot;); if(getVal(tmp, 1, 1) != 4) return termine(&quot;mcs - La valeur de la case [1,1] ne devait pas changer.&quot;); return 1; } 5 - Fonction test_mouvement int test_mouvement(){ int n = 2; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); \/\/ On r\u00c3\u00a9alise un tour de la grille et on v\u00c3\u00a9rifie les valeurs des cases de la grille \/\/ BAS - GAUCHE - HAUT - DROITE setVal(tmp, 0, 1, 2); int res = mouvement(tmp, 0); if(res != 1) return termine(&quot;m - Le mouvement vers le bas a echou\u00c3\u00a9&quot;); if(getVal(tmp, 0, 1) != 0) return termine(&quot;La valeur de la case [0,1] n'a pas \u00c3\u00a9t\u00c3\u00a9 r\u00c3\u00a9initialis\u00c3\u00a9e.&quot;); res = mouvement(tmp, 3); if(res != 1) return termine(&quot;Le mouvement vers la gauche a echou\u00c3\u00a9&quot;); if(getVal(tmp, 1, 1) != 0) return termine(&quot;La valeur de la case [1,1] n'a pas \u00c3\u00a9t\u00c3\u00a9 r\u00c3\u00a9initialis\u00c3\u00a9.&quot;); res = mouvement(tmp, 2); if(res != 1) return termine(&quot;le mouvement vers le haut a \u00c3\u00a9chou\u00c3\u00a9&quot;); if(getVal(tmp, 1, 0) != 0) return termine(&quot;La valeur de la case [1,0] n'a pas \u00c3\u00a9t\u00c3\u00a9 r\u00c3\u00a9initialis\u00c3\u00a9.&quot;); res = mouvement(tmp, 1); if(res != 1) return termine(&quot;Le mouvement vers la droite a echou\u00c3\u00a9.&quot;); if(getVal(tmp, 0, 0) != 0) return termine(&quot;La valeur de la case [0,0] n'a pas \u00c3\u00a9t\u00c3\u00a9 r\u00c3\u00a9initialis\u00c3\u00a9.&quot;); \/\/ On modifie les valeurs de la grille setVal(tmp, 0, 0, 32); setVal(tmp, 1, 0, 64); setVal(tmp, 1, 1, 2); \/\/ On r\u00c3\u00a9alise un mouvement vers la Gauche (impossible) res = mouvement(tmp, 3); if(res != 0) return termine(&quot;les cases ne devraient pas bouger vers la gauche&quot;); \/\/ On r\u00c3\u00a9alise un mouvement vers bas (possible) et on verifie la valeur dans la grille res = mouvement(tmp, 0); if(res != 1) return termine(&quot;la case [0,1] devait bouger sur la case [1,1]&quot;); if(getVal(tmp, 1,1) != 4) return termine(&quot;La valeur de la case [1,1] n'est pas \u00c3\u00a9gale \u00c3\u00a0 4.&quot;); \/\/ On test de sortir de la grille avec cette fonction res = mouvement(tmp, 0); if(res != 0) return termine(&quot;m - 1 - Mouvement interdit&quot;); mouvement(tmp, 1); res = mouvement(tmp, 1); if(res != 0) return termine(&quot;m - 2 - Mouvement interdit&quot;); return 1; } 6 - Fonction test_saisieD int test_saisieD(){ \/** * Fonction Sp\u00c3\u00a9ciale interaction avec l'utilisateur : * L'utilisateur doit tester si les touches qu'on lui demande sont * correctes. (3 essaies possible par touche) *\/ printf(&quot;\\033[33;01mTest interactif - Clavier \\033[00m\\n&quot;); printf(&quot;Il n'y a que 5 touches fonctionnelles lors de ce jeu \\n - ECHAP \\n - Fl\u00c3\u00a8che 'HAUT' \\ \\n - Fl\u00c3\u00a8che 'BAS' \\n - Fl\u00c3\u00a8che 'DROITE' \\n - Fl\u00c3\u00a8che 'GAUCHE' \\ \\n \\033[31;01m(3 essaie par Touche)\\033[00m\\n&quot;); int res, essaie = 1; do{ printf(&quot;Appuyez sur la touche 'ECHAP' (%d\/3)\\n&quot;, essaie); fflush(stdout); res = saisieD(); essaie++; }while(res != -1 &amp;&amp; essaie &lt;= 3); if(essaie &gt; 3) return termine(&quot;La Touche echap ne fonctionne pas. (ou c'est une erreur de saisie volontaire)&quot;); essaie = 1; do{ printf(&quot;Appuyez sur la fl\u00c3\u00a8che 'HAUT' (%d\/3)\\n&quot;, essaie); fflush(stdout); res = saisieD(); essaie++; }while(res != 2 &amp;&amp; essaie &lt;= 3); if(essaie &gt; 3) return termine(&quot;la fl\u00c3\u00a8che 'HAUT' ne fonctionne pas. (ou c'est une erreur de saisie volontaire)&quot;); essaie = 1; do{ printf(&quot;Appuyez sur la fl\u00c3\u00a8che 'BAS' (%d\/3)\\n&quot;, essaie); fflush(stdout); res = saisieD(); essaie++; }while(res != 0 &amp;&amp; essaie &lt;= 3); if(essaie &gt; 3) return termine(&quot;La fl\u00c3\u00a8che 'BAS' ne fonctionne pas. (ou c'est une erreur de saisie volontaire)&quot;); essaie = 1; do{ printf(&quot;Appuyez sur la fl\u00c3\u00a8che 'DROITE' (%d\/3)\\n&quot;, essaie); fflush(stdout); res = saisieD(); essaie++; }while(res != 1 &amp;&amp; essaie &lt;= 3); if(essaie &gt; 3) return termine(&quot;la fl\u00c3\u00a8che 'DROITE' ne fonctionne pas. (ou c'est une erreur de saisie volontaire)&quot;); essaie = 1; do{ printf(&quot;Appuyez sur la fl\u00c3\u00a8che 'GAUCHE' (%d\/3)\\n&quot;, essaie); fflush(stdout); res = saisieD(); essaie++; }while(res != 3 &amp;&amp; essaie &lt;= 3); if(essaie &gt; 3) return termine(&quot;la fl\u00c3\u00a8che 'GAUCHE' ne fonctionne pas. (ou c'est une erreur de saisie volontaire)&quot;); return 1; } 7 - Fonction test_jouer int test_jouer(){ \/** * Fonction Sp\u00c3\u00a9ciale : Propose 3 situations de jeu * demandant une interaction de l'utilisateur * *\/ int n = 2; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); setVal(tmp, 0, 1, 2); int res, essaie = 1; do{ printf(&quot;\\033[34;01mUne partie va \u00c3\u00aatre lanc\u00c3\u00a9e Appuyez sur echap. (%d\/3)\\033[00m\\n&quot;, essaie); fflush(stdout); sleep(2); res = jouer(tmp); essaie++; }while(res != 0 &amp;&amp; essaie &lt;= 3); if(essaie &gt; 3 &amp;&amp; res != 0) return termine(&quot;La partie ne renvoie pas 0 ou vous n'appuyez pas sur 'ECHAP'&quot;); setVal(tmp, 0, 0, 1045); setVal(tmp, 0, 1, 1046); setVal(tmp, 1, 0, 1047); setVal(tmp, 1, 1, 1049); essaie = 1; do{ printf(&quot;\\033[34;01mUne partie va \u00c3\u00aatre lanc\u00c3\u00a9e Appuyez sur fl\u00c3\u00a8che directionnelle. (%d\/3)\\033[00m\\n&quot;, essaie); fflush(stdout); sleep(2); res = jouer(tmp); essaie++; }while(res != 1 &amp;&amp; essaie &lt;= 3); if(essaie &gt; 3 &amp;&amp; res != 0) return termine(&quot;La partie ne renvoie pas 1 ou vous n'appuyez pas une fl\u00c3\u00a8che directionnelle.&quot;); setVal(tmp, 0, 0, 0); setVal(tmp, 0, 1, 0); setVal(tmp, 1, 0, 0); setVal(tmp, 1, 1, 2048); essaie = 1; do{ printf(&quot;\\033[34;01mUne partie va \u00c3\u00aatre lanc\u00c3\u00a9e Appuyez sur fl\u00c3\u00a8che directionnelle. (%d\/3)\\033[00m\\n&quot;, essaie); fflush(stdout); sleep(2); res = jouer(tmp); essaie++; }while(res != 1 &amp;&amp; essaie &lt;= 3); if(essaie &gt; 3 &amp;&amp; res != 0) return termine(&quot;La partie ne renvoie pas 1 ou vous n'appuyez pas une fl\u00c3\u00a8che directionnelle.&quot;); return 1; } 8 - Fonction test_partie3 void test_partie3(){ int somme = 0; somme += test_mouvementLigne(); somme += test_mouvementLignes(); somme += test_mouvementColonne(); somme += test_mouvementColonnes(); somme += test_mouvement(); somme += test_saisieD(); if(somme == 6) somme += test_jouer(); if(somme != 7) termine(&quot;TOUS LES TESTS DE LA PARTIE 3 NE SONT PAS PASSES !&quot;); else{ printf(&quot;\\033[32;01m#########################\\n&quot;); printf(&quot;# TESTS PARTIE 3 OK #\\n&quot;); printf(&quot;######################### \\033[00m\\n&quot;); } }","tags":"","url":"Tests_unitaires\/Test_mouvement.html"},{"title":"Test sauvegarde & menu","text":"Auteur : Jerent Steeve 1 - Fonction test_sauvegarde 2 - Fonction test_chargement 3 - Fonction test_menu 4 - Fonction test_partie4 Auteur : Jerent Steeve 1 - Fonction test_sauvegarde int test_sauvegarde(){ int n = 4; \/\/ 418 est la valeur max pour lancer les tests en sauvegardeJeu \/\/ Histoire : 418 est un code de status http cr\u00c3\u00a9er par google, pour rire. \/\/ signifiant &quot;I'm a teapot&quot; =&gt; &quot;Je suis une th\u00c3\u00a9i\u00c3\u00a8re&quot; int res; int vMax = 418; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); ajouteValAlea(tmp); ajouteValAlea(tmp); ajouteValAlea(tmp); ajouteValAlea(tmp); \/\/ on cr\u00c3\u00a9e un fichier de sauvegarde res = sauvegardeJeu(tmp); remove(&quot;.\/Saves\/test_Iam_a_teampot.bin&quot;); if(res != 1) return termine(&quot;La sauvegarde n'a pas \u00c3\u00a9t\u00c3\u00a9 cr\u00c3\u00a9\u00c3\u00a9e. Ou vous avez coup\u00c3\u00a9 le dernier test de mani\u00c3\u00a8re brutale.&quot;); res = sauvegardeJeu(tmp); int essaie = 1; \/\/ on v\u00c3\u00a9rifie le cas o\u00c3\u00b9 le choix [n|N] ne fonctionnerait pas do{ printf(&quot;\\033[33;01mSaisir 'n' ou 'N' pour valider la suppression\\n\\033[31;01mEssaie : (%d\/3)\\033[00m\\n&quot;, essaie); res = sauvegardeJeu(tmp); essaie++; }while (essaie&lt;=3 &amp;&amp; res != 0); \/\/ La supression du fichier n'est pas faite pour ex\u00c3\u00a9cuter le test_chargement if(essaie &gt; 3) return termine(&quot;Le nombre de tentative est d\u00c3\u00a9pass\u00c3\u00a9. le choix [n|N] ne fonctionne pas&quot;); return 1; } 2 - Fonction test_chargement int test_chargement(){ int n = 4; int res; int vMax = 418; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); \/\/ on charge le fichier de sauvegarde pour les tests .\/Saves\/test_Iam_a_teampot.bin res = chargementJeu(tmp); if(res != 1) return termine(&quot;Le chargement n'a pas pu \u00c3\u00aatre effectu\u00c3\u00a9&quot;); \/\/ Supression du fichier de sauvegarde pour les tests remove(&quot;.\/Saves\/test_Iam_a_teampot.bin&quot;); res = chargementJeu(tmp); if(res != 0) return termine(&quot;Le chargement ne devait pas \u00c3\u00aatre r\u00c3\u00a9alis\u00c3\u00a9 apr\u00c3\u00a8s supression du fichier de sauvegarde&quot;); return 1; } 3 - Fonction test_menu int test_menu(){ \/\/ Test special : on fait le testeur rentrer \/\/ chaque valeur pour voir si elles correspondent int i=1, choix; do{ printf(&quot;\\033[33;01mEntrez le chiffre 1 et validez avec Entr\u00c3\u00a9e\\n\\033[31;01mEssaie : (%d\/3)\\033[00m\\n&quot;, i); choix = menu(); i++; }while(i&lt;=3 &amp;&amp; choix != 1); if(i&gt;3) return termine(&quot;Saisie \u00c3\u00a9chou\u00c3\u00a9e&quot;); i=1; do{ printf(&quot;\\033[33;01mEntrez le chiffre 2 et validez avec Entr\u00c3\u00a9e\\n\\033[31;01mEssaie : (%d\/3)\\033[00m\\n&quot;, i); choix = menu(); i++; }while(i&lt;=3 &amp;&amp; choix != 2); if(i&gt;3) return termine(&quot;Saisie \u00c3\u00a9chou\u00c3\u00a9e&quot;); i=1, choix; do{ printf(&quot;\\033[33;01mEntrez le chiffre 3 et validez avec Entr\u00c3\u00a9e\\n\\033[31;01mEssaie : (%d\/3)\\033[00m\\n&quot;, i); choix = menu(); i++; }while(i&lt;=3 &amp;&amp; choix != 3); if(i&gt;3) return termine(&quot;Saisie \u00c3\u00a9chou\u00c3\u00a9e&quot;); i=1, choix; do{ printf(&quot;\\033[33;01mEntrez le chiffre 4 et validez avec Entr\u00c3\u00a9e\\n\\033[31;01mEssaie : (%d\/3)\\033[00m\\n&quot;, i); choix = menu(); i++; }while(i&lt;=3 &amp;&amp; choix != 4); if(i&gt;3) return termine(&quot;Saisie \u00c3\u00a9chouer&quot;); i=1, choix; do{ printf(&quot;\\033[33;01mEntrez le chiffre 5 et validez avec Entr\u00c3\u00a9e\\n\\033[31;01mEssaie : (%d\/3)\\033[00m\\n&quot;, i); choix = menu(); i++; }while(i&lt;=3 &amp;&amp; choix != 5); if(i&gt;3) return termine(&quot;Saisie \u00c3\u00a9chou\u00c3\u00a9e&quot;); i=1, choix; do{ printf(&quot;\\033[33;01mEntrez le chiffre 6 et validez avec Entr\u00c3\u00a9e\\n\\033[31;01mEssaie : (%d\/3)\\033[00m\\n&quot;, i); choix = menu(); i++; }while(i&lt;=3 &amp;&amp; choix != 6); if(i&gt;3) return termine(&quot;Saisie \u00c3\u00a9chou\u00c3\u00a9e&quot;); return 1; } 4 - Fonction test_partie4 void test_partie4(){ int somme = 0; somme += test_sauvegarde(); somme += test_chargement(); somme += test_menu(); if(somme != 3) termine(&quot;TOUS LES TESTS DE LA PARTIE 4 NE SONT PAS PASSES !&quot;); else{ printf(&quot;\\033[32;01m#########################\\n&quot;); printf(&quot;# TESTS PARTIE 4 OK #\\n&quot;); printf(&quot;######################### \\033[00m\\n&quot;); } }","tags":"","url":"Tests_unitaires\/Test_sauvegarde_&_menu.html"},{"title":"sources","text":"Information sur le jeux 2048 : https:\/\/fr.wikipedia.org\/wiki\/2048_(jeu_vid\u00c3\u00a9o) G\u00c3\u00a9n\u00c3\u00a9ration de la documentation : http:\/\/daux.io\/ Test de la grille : Document de test de la grille du jeu 2048 fournis par monsieur B. KHAFIF.","tags":"","url":"sources.html"}]}