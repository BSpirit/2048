{"pages":[{"title":"Projet DUT AS - 2048","text":"Test","tags":"","url":"index.html"},{"title":"Getting started","text":"Pr\u00c3\u00a9requis : make gcc Lancement de l'application. Pour compiler l'application : $ make compile Ex\u00c3\u00a9cuter l'application : $ .\/2048 # Ou faire la commande suivante pour supprimer l'ancienne ex\u00c3\u00a9cutable # cr\u00c3\u00a9er un nouvel ex\u00c3\u00a9cutable et l'ex\u00c3\u00a9cuter. $ make run Lancement des Tests Unitaires Compiler le programme de test : $ make compileTest Ex\u00c3\u00a9cuter le programme de test: $ .\/test # Ou faire la commande suivante pour supprimer l'ancienne ex\u00c3\u00a9cutable # cr\u00c3\u00a9er un nouvel ex\u00c3\u00a9cutable et l'ex\u00c3\u00a9cuter. $ make test","tags":"","url":"Getting_started.html"},{"title":"partie 1","text":"1 - Structure de donn\u00c3\u00a9es Jeu typedef struct{ int n; \/\/taille de la grille = n*n int valMax; \/\/ valeur \u00c3\u00a0 atteindre pour gagner int nbCasesLibres; \/\/nbre de cases libres sur la grille int score; \/\/score de la partie en cours int *grille; }jeu; 2 - Fonction initialiseJeu \/*! * Alloue la grille de la variable jeu pass\u00c3\u00a9e par adresse. * Initialise les cases de la grille avec des cases vides (valeur nulles) * Initialise les champs n et valMax avec les valeurs pass\u00c3\u00a9es en param\u00c3\u00a8tre * * \\param p : Pointeur sur une partie de 2048 * \\param n : Taille de la grille * \\param valMax : Valeur \u00c3\u00a0 atteindre pour gagner * *\/ void initialiseJeu(jeu *p, int n, int valMax){ \/\/Initialisation des variables p-&gt;n = n; p-&gt;nbCasesLibres = n*n; p-&gt;valMax = valMax; p-&gt;score = 0; \/\/allocation dynamique de la taille de la grille p-&gt;grille = (int*) malloc(p-&gt;nbCasesLibres*sizeof(int)); if(p-&gt;grille==NULL){ printf(&quot;Erreur allocation ! \\n&quot;); exit(-1); } \/\/Initialisation des cases de la grille \u00c3\u00a0 0 int i; for(i=0;i&lt;p-&gt;nbCasesLibres;i++) p-&gt;grille[i] = 0; } 3 - Fonction LibereMemoire \/*! * Lib\u00c3\u00a8re la m\u00c3\u00a9moire allouer pour la grille du jeu pass\u00c3\u00a9 par adresse. * * \\param p : pointeur sur la partie de 2048 *\/ void libereMemoire(jeu *p){ free(p-&gt;grille); } 4 - Fonction indiceValide \/*! * Fonction retournant 1 si la case (i, j) existe, 0 sinon. * * \\param p : Pointeur sur la partie de 2048 * \\param i : Ligne de la case cibl\u00c3\u00a9 * \\param j : colonne de la case cibl\u00c3\u00a9 *\/ int indiceValide(jeu *p, int i, int j){ \/\/les indices i et j doivent \u00c3\u00aatre compris entre 0 (inclus) et p-&gt;n (exclus) return (i&gt;=0 &amp;&amp; i &lt; p-&gt;n &amp;&amp; j&gt;=0 &amp;&amp; j &lt; p-&gt;n); } 5 - Fonction getVal \/*! * Fonction retournant la valeur de la case (ligne, colonne) de la partie p * ou -1 si la case n'existe pas. * * \\param p : pointeur sur la partie en cours * \\param ligne : entier correspondant au numero de ligne * \\param colonne : entier correspondant au num\u00c3\u00a9ro de colonne *\/ int getVal(jeu *p, int ligne, int colonne){ if(indiceValide(p, ligne, colonne)) return p-&gt;grille[p-&gt;n*ligne+colonne]; return -1; } 6 - Fonction setVal \/*! * Fonction modifiant la valeur de la case (ligne, colonne) de la partie p, * avec la valeur val * * \\param p : pointeur sur la partie en cours * \\param ligne : entier correspondant au numero de ligne * \\param colonne : entier correspondant au num\u00c3\u00a9ro de colonne * \\param val : entier \u00c3\u00a0 mettre dans la case (i,j) (si elle existe) *\/ int setVal(jeu *p, int ligne, int colonne, int val){ \/\/ On verifie que l'indice est valide if(indiceValide(p, ligne, colonne)){ \/\/ si la valeur de la case est identique \u00c3\u00a0 val, on ne fait rien if(getVal(p, ligne, colonne) == val) return 0; \/\/si une ajoute une valeur \u00c3\u00a0 une case vide, on d\u00c3\u00a9cr\u00c3\u00a9mente le nombre de cases vides if(caseVide(p, ligne, colonne) &amp;&amp; val &gt; 0) p-&gt;nbCasesLibres--; \/\/si on vide une case, on incr\u00c3\u00a9mente le nombre de cases vides if(!caseVide(p, ligne, colonne) &amp;&amp; val == 0 ) p-&gt;nbCasesLibres++; \/\/modification de la valeur de la case p-&gt;grille[p-&gt;n*ligne+colonne] = val; return 1; } return 0; } 7 - Fonction affichage \/*! * Fonction affichant la grille \u00c3\u00a0 l'\u00c3\u00a9cran * * \\param p : pointeur sur la partie en cours. *\/ void affichage(jeu * p){ clear_terminal(); int val; \/\/boucles imbriqu\u00c3\u00a9es pour parcourir la grille int i; for(i=0;i&lt;p-&gt;n;i++){ \/\/Retour chariot \u00c3\u00a0 la fin d'une ligne printf(&quot;\\n&quot;); int j; for(j=0; j&lt;p-&gt;n; j++){ val = getVal(p, i, j); \/\/Si la case est vide on l'affiche int\u00c3\u00a9gralement en noir if(val == 0) color_printf(BLACK, BLACK, &quot; &quot;); \/\/sinon on appelle la fonction choixCouleur pour lui assigner une couleur else color_printf(WHITE, choixCouleur(val), &quot; %5d &quot;, val); } } printf(&quot;\\n&quot;); printf(&quot;Score : %d\\n\\n&quot;, p-&gt;score); if(gagne(p)) printf(&quot;Vous avez gagn\u00c3\u00a9 ! \\n\\n&quot;); else if(perdu(p)) printf(&quot;Vous avez perdu ! \\n\\n&quot;); }","tags":"","url":"Programme\/partie_1.html"},{"title":"partie 2","text":"8 - Fonction caseVide \/*! * Retourne 1 si la case est vide, 0 sinon. * * \\param p : pointeur sur la partie en cours * \\param ligne : entier correspondant au numero de ligne * \\param colonne : entier correspondant au num\u00c3\u00a9ro de colonne *\/ int caseVide(jeu *p, int i, int j){ if(getVal(p, i, j)==0) return 1; return 0; } 9 - Fonction ajoutValAlea \/*! * Ajoute une valeur (2 ou 4 choisi al\u00c3\u00a9atoirement) sur une case vide * (elle aussi choisi aleatoirement) * * \\param p : pointeur sur la partie en cours *\/ void ajouteValAlea(jeu *p){ int ligne; int colonne; if(p-&gt;nbCasesLibres&gt;0){ \/\/On g\u00c3\u00a9n\u00c3\u00a8re des indices (ligne, colonne) jusqu'\u00c3\u00a0 tomber sur une case vide do{ ligne = rand()%p-&gt;n; colonne = rand()%p-&gt;n; }while(!caseVide(p, ligne, colonne)); \/\/ On assigne 2 ou 4 \u00c3\u00a0 la case s\u00c3\u00a9lectionn\u00c3\u00a9e if(rand()%2) setVal(p, ligne, colonne, 2); else setVal(p, ligne, colonne, 4); } } 10 - Fonction gagne \/*! * Retourne 1 si la partie est gagn\u00c3\u00a9e, 0 sinon. * * \\param p : Pointeur sur la partie en cours *\/ int gagne(jeu *p){ int flag = 0; int i = 0;\/\/ indice de ligne int j = 0;\/\/ indice de colonne \/\/boucles imbriqu\u00c3\u00a9es pour parcourir la grille while(i&lt;p-&gt;n &amp;&amp; flag==0){ j = 0; while(j&lt;p-&gt;n &amp;&amp; flag==0){ if(getVal(p, i, j)==p-&gt;valMax) flag = 1; j++; } i++; }\/\/sortie : grille enti\u00c3\u00a8rement parcourue ou une case de la grille a pour valeur p-&gt;valMax (flag==1) \/\/ flag==1 uniquement si une des cases de la grille a comme valeur p-&gt;valMax return flag; } 11 - Fonction perdu \/*! * Retourne 1 si la partie est perdu,0 sinon. * * \\param p : Pointeur sur la partie en cours *\/ int perdu(jeu *p){ \/\/S'il reste des cases libres, on n'a pas perdu if(p-&gt;nbCasesLibres&gt;0) return 0; int flag = 1; int i = 0; \/\/indice de ligne int j = 0;\/\/ indice de colonne \/\/Boucles imbriqu\u00c3\u00a9es pour parcourir la grille, on commence \u00c3\u00a0 la case (0,0) while(i&lt;p-&gt;n &amp;&amp; flag==1){ j = 0; while(j&lt;p-&gt;n &amp;&amp; flag==1){ \/\/ si on arrive \u00c3\u00a0 la derni\u00c3\u00a8re case de la grille, c'est qu'on a perdu if(i==p-&gt;n-1 &amp;&amp; j==p-&gt;n-1) flag = 1; \/\/ sinon on compare la case actuelle avec celle \u00c3\u00a0 droite et celle en dessous else if(getVal(p, i, j)==getVal(p, i+1, j) || getVal(p, i, j)==getVal(p, i, j+1)) flag = 0; j++; } i++; } \/* * sortie : grille enti\u00c3\u00a8rement parcourue (flag==1, on a perdu) ou * deux cases adjacentes ont les m\u00c3\u00aames valeurs (flag==0 i.e. on n'a pas encore perdu) *\/ return flag; } 12 - Fonction finPartie \/*! * Retourne 1 si la partie est termin\u00c3\u00a9, 0 sinon. * * \\param p : Pointeur sur la partie en cours *\/ int finPartie(jeu *p){ return (perdu(p) || gagne(p)); }","tags":"","url":"Programme\/partie_2.html"},{"title":"partie 3","text":"","tags":"","url":"Programme\/partie_3.html"},{"title":"partie 4","text":"","tags":"","url":"Programme\/partie_4.html"},{"title":"partie 1","text":"1 - Fonction termine Permet d'afficher les messages d'erreurs lors des tests unitaire et retourne 0 pour signaler l'erreur. int termine(const char *ch){ printf(&quot;\\033[31;01m***********************\\n&quot;); printf(&quot;******* Erreur ********\\n&quot;); printf(&quot;***********************\\n&quot;); printf(&quot;* %s *\\033[00m\\n&quot;, ch); return 0; } 2 - Fonction int test_creer_initialiseJeu Cas de test : Test de la valeur max : On v\u00c3\u00a9rifie si la valeur max n'est pas diff\u00c3\u00a9rente de celle donn\u00c3\u00a9e dans la norme. Test du nombre de case libre : Apr\u00c3\u00a8s initialisation de la partie on v\u00c3\u00a9rifie si nbCaseLibre est \u00c3\u00a9gale \u00c3\u00a0 n * n. On r\u00c3\u00a9alise une seconde v\u00c3\u00a9rification, en fesant la somme des valeurs composant la grille pour d\u00c3\u00a9terminer si elle vaut 0 int test_creer_initialiseJeu(){ int i; int n = 4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); if(tmp-&gt;valMax != vMax) return termine(&quot;La valeur maximun \u00c3\u00a0 atteindre n'est pas correcte ! &quot;); if(tmp-&gt;nbCasesLibres != n*n) return termine(&quot;Le nombre de case libre n'est pas correct !&quot;); int somme = 0; for(i=0; i&lt;n*n; i++) somme+=tmp-&gt;grille[i]; if(somme != 0) return termine(&quot;La grille ne contient pas que des cases libres !&quot;); libereMemoire(tmp); return 1; } 3 - Fonction test_indice_valide Cas de test : Test indice case : On cumule chaque indice valide de notre grille et on v\u00c3\u00a9rifie si elle vaut n * n. Puis nous r\u00c3\u00a9alisons des tests si l'indice est hors des limites de la grille int test_indice_valide(){ int n=4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp ,n,vMax); int i,j; int somme = 0; for(i = 0 ; i &lt; n ; i++) for(j = 0 ; j &lt;n ; j++) somme += indiceValide(tmp,i,j); if (somme != n*n) return termine(&quot;indice =Valide ne retourne pas 1 correctement&quot;); if(indiceValide(tmp,-1,2) || indiceValide(tmp,n,2)) return termine(&quot;indiceValide ne retourne pas 0 correctement !&quot;); if(indiceValide(tmp,3,-1) || indiceValide(tmp,3,n)) return termine(&quot;indiceValide ne retourne pas 0 correctement !&quot;); libereMemoire(tmp); return 1; } 4 - Fonction test_fonction_get_val Cas de tests : Test valeur case : On rempli une grille de jeu avec des valeurs puis on v\u00c3\u00a9rifie la somme des valeurs de la grille int test_fonction_get_val(){ int n=6; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp,n,vMax); int i,j; int somme = 0; for(i = -1 ; i &lt;= n ; i++) for(j = -1 ; j &lt;= n ; j++) somme += getVal(tmp,i,j); if (somme != -28) return termine(&quot;La case n'est pas vide ou getVal ne retourne pas -1 quand on n'est pas sur la case&quot;); for(i = 7 ; i &lt;= 10 ; i++) tmp-&gt;grille[i] = i -6; somme=0; for(i=0; i&lt;=5;i++) for(j=0; j&lt;=5; j++) somme += getVal(tmp, i, j); if (somme != 10) return termine(&quot;getVal ne retourne pas la bonne valeur !&quot;); libereMemoire(tmp); return 1; } 5 - Fonction test_fonction_set_val Cas de test : Test set valeur : On set les valeurs de plusieurs case et on test si la fonction \"setVal\" renvoie 1. Test nbCasesLibres : On v\u00c3\u00a9rifie si le nombre de case libre s'incr\u00c3\u00a9mente ou d\u00c3\u00a9cr\u00c3\u00a9mente en fonction de la valeur \u00c3\u00a0 mise dans la case. 0 - incr\u00c3\u00a9mente sup. 0 - d\u00c3\u00a9cr\u00c3\u00a9mente int test_fonction_set_val(){ int n=6; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp,n,vMax); int res = setVal(tmp, 1,1,5); if(res != 1) return termine(&quot;set valeur ne retourne pas la bonne valeur !&quot;); if(tmp-&gt;nbCasesLibres != 35) return termine(&quot;Le nombre de case libre n'est pas correct ! test&quot;); if(tmp-&gt;grille[7] != 5) return termine(&quot;setVal ne modifie pas correctement la case !&quot;); res = setVal(tmp, 18,2,5); if(res != 0) return termine(&quot;setVAl ne renvoie pas la bonne valeur ! L'indice de ligne n'est pas bon !&quot;); res = setVal(tmp, -1,2,7); if(res != 0) return termine(&quot;setVAl ne renvoie pas la bonne valeur ! L'indice de ligne n'est pas bon !&quot;); res = setVal(tmp, 0, 2, 3); if(res != 1) return termine(&quot;setVal ne renvoie pas la bonne valeur !&quot;); if(tmp-&gt;nbCasesLibres != 34) return termine(&quot;Le nombre de case libre n'est pas correcte ! On modifie la bordure !&quot;); if (tmp-&gt;grille[2] != 3) return termine(&quot;setVal ne modifie pas correctement la valeur !&quot;); res = setVal(tmp, 1,1,3); if (res != 1) return termine(&quot;setVal ne renvoie pas la bonne valeur !&quot;); if (tmp-&gt;nbCasesLibres != 34) return termine(&quot;le nombre de case libre n'est pas correct !&quot;); if(tmp-&gt;grille[7] != 3) return termine(&quot;setVal ne modifie pas correctement le jeu !&quot;); res = setVal(tmp, 1,1,0); if (res != 1) return termine(&quot;set valeur ne renvoie pas la bonne valeur !&quot;); if (tmp-&gt;nbCasesLibres != 35) return termine(&quot;le nombre de cases de libres n'est pas correct !&quot;); if (tmp-&gt;grille[7] != 0) return termine(&quot;setVal ne modifie pas correctement le jeu !&quot;); libereMemoire(tmp); return 1; } 6 - Fonction test_partie1 Permet de caculer le score des tests r\u00c3\u00a9alis\u00c3\u00a9 lors de cette partie, afin de valider les fonctions utilis\u00c3\u00a9. void test_partie1(){ int somme = 0; somme += test_creer_initialiseJeu(); somme += test_indice_valide(); somme += test_fonction_get_val(); somme += test_fonction_set_val(); if(somme != 4) termine(&quot;TOUS LES TESTS DE LA PARTIE 1 NE SONT PAS PASSES !&quot;); else{ printf(&quot;\\033[32;01m#########################\\n&quot;); printf(&quot;# TESTS PARTIE 1 OK #\\n&quot;); printf(&quot;#########################\\033[00m\\n&quot;); } } Source Document de test de la partie 1 du jeu 2048 fournis par monsieur B. KHAFIF.","tags":"","url":"Test_unitaire\/partie_1.html"},{"title":"partie 2","text":"Autheur : Jerent Steeve 1 - Fonction test_case_vide Cas de test : Test case : On test une case rempli dans la grille puis une vide. Test case hors grille : On test une case hors de la grille. la fonction caseVide doit retourner 0. Test case grille rempli totalement : On a fait la somme des case remplis dans le tableau le comparer \u00c3\u00a0 n*n Test case grille vide : On a fait la somme des case vides dans le tableau le comparer \u00c3\u00a0 n*n int test_case_vide(){ int i, j; int n = 4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); setVal(tmp, 1, 3, 5); int res = caseVide(tmp, 1, 3); if(res != 0) return termine(&quot;La case est vide.&quot;); setVal(tmp, 1, 3, 0); res = caseVide(tmp, 1, 3); if(res != 1) return termine(&quot;La case n'est pas vide.&quot;); res = caseVide(tmp, 9, 9); if(res != 0) return termine(&quot;La case n'existe pas.&quot;); for(i=0; i&lt;=n;i++) for(j=0; j&lt;=n; j++) setVal(tmp, i, j, 1); int somme = 0; for(i=0; i&lt;n;i++) for(j=0; j&lt;n; j++) somme += caseVide(tmp, i, j); if(somme != 0) return termine(&quot;Un case ou plusieurs cases du tableau ne sont pas vide&quot;); for(i=0; i&lt;=n;i++) for(j=0; j&lt;=n; j++) setVal(tmp, i, j, 0); somme = 0; for(i=0; i&lt;n;i++) for(j=0; j&lt;n; j++) somme += caseVide(tmp, i, j); if (somme != 16) return termine(&quot;Une case ou plusieurs case sont rempli&quot;); libereMemoire(tmp); return 1; } 2 - Fonction test_ajouter_val_aleatoire Cas de test : Test case : Test case : int test_ajouter_val_aleatoire(){ int i, j; int n = 4; int vMax = 2048; jeu jeu_test; jeu * tmp = &amp;jeu_test; initialiseJeu(tmp, n, vMax); ajouteValAlea(tmp); int compteur = 0; for(i=0; i&lt;n;i++){ for(j=0; j&lt;n; j++){ if(getVal(tmp, i, j) == 2 || getVal(tmp, i, j) == 4){ compteur++; setVal(tmp, i, j, 0); } } } if(compteur == 0) return termine(&quot;Aucun valeur aleatoire n'as \u00c3\u00a9t\u00c3\u00a9 rajouter.&quot;); if(compteur &gt; 1) return termine(&quot;Plusieurs valeurs aleatoires ont \u00c3\u00a9t\u00c3\u00a9 toruver.&quot;); int l = 0; int nb_2 = 0; int nb_4 = 0; while(l&lt;1000 &amp;&amp; (nb_2 == 0 || nb_4 == 0)){ ajouteValAlea(tmp); for(i=0; i&lt;n;i++){ for(j=0; j&lt;n; j++){ if(getVal(tmp, i, j) == 2){ nb_2++; setVal(tmp, i, j, 0); }else if(getVal(tmp, i, j) == 4){ nb_4++; setVal(tmp, i, j, 0); } } } l++; } if(nb_2 == 0 || nb_4 == 0) return termine(&quot;L'une des 2 valeurs aleatoires est manquante.&quot;); int case_alea = 0; int pos_ligne = -1, pos_colonne=-1; l=0; while(l&lt;10){ ajouteValAlea(tmp); for(i=0; i&lt;n;i++){ for(j=0; j&lt;n; j++){ if(getVal(tmp, i, j) == 2 || getVal(tmp, i, j) == 4){ if(i != pos_ligne &amp;&amp; j != pos_colonne){ pos_ligne = i; pos_colonne = j; setVal(tmp, i, j, 0); case_alea--; }else{ case_alea++; setVal(tmp, i, j, 0); } } } } l++; } if(case_alea == 10) return termine(&quot;Les valeur 2 et 4 n'apparaissent pas al\u00c3\u00a9atoirement.'&quot;); for(i=0; i&lt;=n;i++) for(j=0; j&lt;=n; j++) setVal(tmp, i, j, 1); ajouteValAlea(tmp); compteur=0; for(i=0; i&lt;n;i++){ for(j=0; j&lt;n; j++){ if(getVal(tmp, i, j) == 2 || getVal(tmp, i, j) == 4){ compteur++; setVal(tmp, i, j, 0); } } } if(compteur != 0) return termine(&quot;Un valeur a \u00c3\u00a9t\u00c3\u00a9 rajouter aleatoirement alors que la grille est rempli&quot;); libereMemoire(tmp); return 1; }","tags":"","url":"Test_unitaire\/partie_2.html"},{"title":"partie 3","text":"","tags":"","url":"Test_unitaire\/partie_3.html"},{"title":"partie 4","text":"","tags":"","url":"Test_unitaire\/partie_4.html"}]}